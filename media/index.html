<!--

/**
 * MSXDev Tool Extension for VS Code
 * Copyright (C) 2025  Fausto Pracek
 *
 * This file is part of MSXDev Tool Extension for VS Code.
 *
 * MSXDev Tool Extension for VS Code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MSXDev Tool Extension for VS Code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MSXDev Tool Extension for VS Code. If not, see <https://www.gnu.org/licenses/>.
 */

-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />


  <title>MSX Dev Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    label {
      font-weight: bold;
      margin-right: 5px;
      color: black; /* Change text color to black */
    }
    #filters label {
      color: white; /* Keep filter labels white */
    }
    select, input, button {
      margin: 5px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    thead {
      background-color: #ddd;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
      color: black; /* Change text color to black */
    }
    /* Color squares (for Palettes) */
    .color-square {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      margin: 2px;
      border: 1px solid #999;
      vertical-align: middle;
      box-sizing: border-box;
      cursor: pointer;
      position: relative;
      text-align: center; /* Center text horizontally */
    }
    .color-square span {
      font-size: 12px;
      font-weight: bold;
      display: inline-block;
      width: 100%; /* Ensure the span takes the full width of the square */
      text-align: center; /* Center text horizontally */
    }
    .checkerboard {
      background: repeating-linear-gradient(
        45deg,
        #ccc 0,
        #ccc 5px,
        #fff 5px,
        #fff 10px
      );
      cursor: not-allowed;
    }
    .action-button {
      margin: 2px;
      padding: 3px 5px;
      cursor: pointer;
    }
    .action-button:hover {
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
    .details-view {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .details-buttons {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .imports-buttons {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .main-detail-panel {
      flex: 1;
      display: flex;
    }
    .drawing-panel {
      flex: 1;
      background: #f9f9f9;
      overflow: auto;
    }
    .images-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .splitter {
      background: #ccc;
      width: 5px;
      cursor: col-resize;
    }
    .splitter-horizontal {
      background: #ccc;
      height: 5px;
      cursor: row-resize;
    }
    .image-grid-panel, .patterns-grid-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .image-grid-title, .patterns-grid-title {
      font-weight: bold;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    .color-picker {
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .image-grid, .patterns-grid {
      flex: 1;
      display: grid;
      gap: 5px;
      padding: 10px;
      overflow: auto;
    }
    .image-grid img, .patterns-grid img {
      border: 2px solid black;
      cursor: pointer;
    }
    .image-grid img.focused, .patterns-grid img.focused {
      border: 2px solid red;
      outline: 2px solid black;
    }
    .image-grid img:not(.focused), .patterns-grid img:not(.focused) {
      border: 1px solid white;
    }
    .panel {
      display: none;
    }
    .panel.active {
      display: block;
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9998; /* Default z-index for overlays */
    }
    .color-picker-overlay {
      z-index: 9999; /* Higher z-index for color picker overlay */
    }
    .dialog {
      background: #fff;
      padding: 20px;
      border: 1px solid #666;
      border-radius: 4px;
      min-width: 250px;
      text-align: center;
      color: black;
    }
    .form-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .form-group label {
      width: 150px; /* Adjust this width based on the longest label */
      color: white; /* Set label font color to white */
      text-align: left; /* Align labels to the left */
      margin-right: 10px;
    }
    .form-group input,
    .form-group select,
    .form-group div {
      flex: 1;
    }
    .form-group input[type="file"] {
      flex: 1;
    }
    .color-picker-dialog {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .color-picker-dialog label,
    .color-picker-dialog input,
    .color-picker-dialog button {
      margin: 0 5px;
    }
    .import-dialog {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Align items to the top left */
      justify-content: flex-start;
      width: 900px; /* Fixed width */
      height: 700px; /* Fixed height */
      position: relative; /* Add relative positioning */
    }
    .import-dialog .header,
    .import-dialog .tabs,
    .import-dialog .form-group {
      align-self: flex-start; /* Align individual elements to the left */
    }
    .import-dialog .form-group {
      justify-content: flex-start; /* Align form group contents to the left */
    }
    .import-dialog .form-group label {
      text-align: left; /* Align labels to the left */
      color: black; /* Set label font color to black */
    }
    .import-dialog .form-group input,
    .import-dialog .form-group select {
      text-align: left; /* Align input and select contents to the left */
    }
    .import-dialog .preview-panel {
      display: block; /* Always visible */
      flex: 1;
      background-color: #f9f9f9;
      height: 100%; /* Adjust height to match all fields */
      width: 100%; /* Adjust width to fill the column */
    }
    .import-dialog .selected-image {
      display: block;
      flex: 1;
      background-color: #f9f9f9;
      height: calc(100% - 300px); /* Adjust height to fill available space */
      width: 100%; /* Adjust width to fill the column */
      border: 1px solid #ccc; /* Add border */
      overflow: hidden; /* Hide overflow to enable dragging */
      position: relative; /* Ensure positioning context for the image */
    }
    .selected-image img {
      image-rendering: pixelated; /* Pixelate the image */
      width: 100%; /* Ensure the image fits the container */
      height: auto;
      transform-origin: center; /* Ensure zooming happens from the center */
      position: absolute; /* Allow the image to be positioned absolutely */
      top: 0;
      left: 0;
      cursor: grab; /* Change cursor to indicate draggable */
    }
    .selected-image img:active {
      cursor: grabbing; /* Change cursor when dragging */
    }
    .import-dialog .selected-image {
      display: block;
      flex: 1;
      background-color: #f9f9f9;
      height: calc(100% - 300px); /* Adjust height to fill available space */
      width: 100%; /* Adjust width to fill the column */
      border: 1px solid #ccc; /* Add border */
      overflow: auto; /* Enable scrolling */
    }
    .import-dialog .form-group-container {
      display: flex;
      width: 100%;
    }
    .import-dialog .form-group-container .form-group {
      flex: 1;
    }
    .import-dialog .header {
      font-weight: bold;
      margin-bottom: 20px;
    }
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    .tab-button {
      padding: 10px 20px;
      cursor: pointer;
      border: none;
      background: #ddd;
      margin: 0 5px;
    }
    .tab-button.active {
      background: #bbb;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .transparent-colors {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .transparent-colors input {
      width: 110px; /* Set width to 100px */
    }
    .form-actions {
      position: absolute; /* Position absolutely */
      bottom: 20px; /* 20px from the bottom */
      right: 20px; /* 20px from the right */
      display: flex;
      justify-content: flex-end; /* Align OK and Cancel buttons to the right */
      width: auto;
    }
    .preview-container {
      position: relative;
      height: 100%;
    }
    .preview-image {
      width: 100%;
      height: auto;
      background-color: #ffffff;
      cursor: grab;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: center;
    }
    .background-color-button {
      position: absolute;
      bottom: 0;
      width: 235px;
      text-align: center;
      background-color: #f0f0f0;
      border-top: 1px solid #ccc;
      padding: 5px 0;
    }
    .export-dialog {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      width: 900px;
      height: 700px;
      position: relative;
    }
    .export-dialog .header {
      font-weight: bold;
      margin-bottom: 20px;
      font-size: 20px; /* Imposta la dimensione del testo a 20px */
    }
    .export-dialog td {
      border: none; /* Rimuovi i bordi delle celle */
    }
    .export-dialog .line-numbers {
      user-select: none; /* Impedisce la selezione dei numeri di riga */
      text-align: right;
      padding-right: 10px;
      color: #888;
      white-space: pre; /* Mantiene gli spazi bianchi */
    }
    .export-dialog .export-text {
      width: 100%;
      height: calc(100% - 100px);
      resize: none;
      padding: 10px;
      box-sizing: border-box;
      font-size: 20px; /* Imposta la dimensione del testo a 20px */
      line-height: 1.5;
      border-left: 1px solid #ccc; /* Aggiungi un bordo a sinistra per separare i numeri
           overflow: auto; /* Enable both vertical and horizontal scrolling */
      white-space: pre; /* Preserve whitespace and prevent text wrapping */
    }
    .export-dialog .export-container {
      display: flex;
      width: 100%;
      height: 100%;
    }
    .zoom-controls {
      display: none; /* Hide zoom controls */
    }
    .filter-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .filter-container label {
      margin-right: 5px;
    }
    .filter-container select {
      margin-right: 10px;
    }
    .grid-container {
      margin-top: 20px;
    }
    .grid-container table {
      width: 100%;
      border-collapse: collapse;
    }
    .grid-container th, .grid-container td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
    .grid-container th {
      background-color: #f0f0f0;
    }
    .form-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 20px;
    }
    .form-actions button {
      margin-left: 10px;
    }
    .image-dialog {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      width: 900px;
      height: 700px;
      position: relative;
    }
    .image-dialog .header {
      font-weight: bold;
      margin-bottom: 20px;
    }
    .image-dialog .image-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #f9f9f9;
      border: 1px solid #ccc;
      overflow: auto; /* Enable scrolling */
    }
    .image-dialog .form-actions {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      justify-content: flex-end;
      width: auto;
    }
    .form-actions button {
      margin-left: 10px;
    }
  </style>
</head>
<body>

<div id="mainPanel" class="panel active">
  <!-- FILTERS -->
  <div id="filters">
    <label for="typeSelect">Type:</label>
    <select id="typeSelect">
      <option value="Sprites">Sprites sets</option>
      <option value="Tiles">Tiles sets</option>
      <option value="Maps">Maps sets</option>
      <option value="Fonts">Fonts sets</option>
      <option value="Palettes">Palettes</option>
      <option value="Images">Images sets</option>
      <option value="Animations">Animations sets</option>
    </select>

    <label for="subtypeSelect" id="subtypeLabel" class="hidden">Subtype:</label>
    <select id="subtypeSelect" class="hidden"></select>

   
    <select id="exportLanguageSelect" style="float: right;">
      <option value="c">C</option>
      <option value="asm-sdasz80">Assembly (SDDC)</option>
      <option value="asm-tniasm">Assembly (tniASM)</option>
      <option value="asm-asmsx">Assembly (asMSX)</option>
      <option value="asm-sjasm">Assembly (Syasm)</option>
      <option value="asm-macro80">Assembly (MACRO80)</option>
      <option value="msxc">MSX-C</option>
      <!-- <option value="Pascal">Pascal</option> -->
      <option value="bas">MSX-BASIC</option>
    </select>
    <label style="float: right; margin-left: 10px;padding-top: 5px;">Export language:</label>
    <button id="codeGeneratorButton" style="float: right; margin-left: 10px;">MSXgl code generator...</button>
  </div>

  <!-- DATA TABLE -->
  <table id="dataGrid">
    <thead>
      <tr id="gridHeader"></tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Add button -->
  <button id="addButton">New</button>

  <!-- Edit dialog -->
  <div id="editDialog" class="hidden"></div>
</div>

  <!-- Overlay: colorPicker -->
  <div id="colorPickerOverlay" class="overlay color-picker-overlay">
    <div id="colorPickerDialog" class="dialog color-picker-dialog">
      <label>Choose color:</label>
      <input type="color" id="colorPickerInput" />
      <button id="colorPickerOk">OK</button>
      <button id="colorPickerCancel">Cancel</button>
    </div>
  </div>

  <!-- Overlay: confirm remove -->
  <div id="confirmOverlay" class="overlay">
    <div id="confirmDialog" class="dialog">
      <p>Are you sure to remove this item?</p>
      <button id="confirmOk">Yes</button>
      <button id="confirmCancel">No</button>
    </div>
  </div>

  <!-- Overlay: info message -->
  <div id="infoOverlay" class="overlay">
    <div id="infoDialog" class="dialog">
      <p id="infoMessage"></p>
      <button id="infoOk">OK</button>
    </div>
  </div>

  <!-- Overlay: import dialog -->
  <div id="importDialogOverlay" class="overlay">
    <div id="importDialog" class="dialog import-dialog">
      <label class="header" id="importDialogHeader"></label>
      <div class="tabs">
        <button class="tab-button active" data-tab="generalTab">General</button>
        <button class="tab-button" data-tab="transparentColorsTab">Transparent colors</button>
      </div>
      <table style="width: 100%; height: calc(100% - 150px);">
        <tr>
          <td style="vertical-align: top; width: 70%; height: 100%;">
            <div id="generalTab" class="tab-content active" style="height: 100%;">
              <div id="import-specs">
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="objectColumns">Items quantity (Columns/Rows):</label>
                    <input type="number" id="objectColumns" value="0" />
                    <span>x</span>
                    <input type="number" id="objectRows" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="gapX">Gap (X/Y):</label>
                    <input type="number" id="gapX" value="0" />
                    <span>x</span>
                    <input type="number" id="gapY" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="posX">Start position (X/Y):</label>
                    <input type="number" id="posX" value="0" />
                    <span>x</span>
                    <input type="number" id="posY" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="paletteSelect">Palette:</label>
                    <select id="paletteSelect">
                      <option value="areaonlycolors">Create a new palette (only selected area colors)</option>
                      <option value="allimagecolors">Create a new palette (all image colors)</option>
                      <!-- Palette options will be populated dynamically -->
                    </select>
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label style="display: none;" for="minColorsDistance">Color min. distancy (only for new palettes):</label>
                    <input type="number" id="minColorsDistance" value="1" min="1" max="255" style="display: none;" />
                  </div>
                </div>
                <!-- Aggiungi la combobox per il dithering -->
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="dithering">Dithering:</label>
                    <select id="dithering" name="dithering">
                      <option value="none">No dithering</option>
                      <option value="floyd">Floyd & Steinberg error diffusion algorithm</option>
                      <option value="bayer4">Bayer ordered dispersed dot dithering (order 2 – 4x4 - dithering matrix)</option>
                      <option value="bayer8">Bayer ordered dispersed dot dithering (order 3 – 8x8 - dithering matrix)</option>
                      <option value="bayer16">Bayer ordered dispersed dot dithering (order 4 - 16x16 dithering matrix)</option>
                      <option value="cluster6">Ordered clustered dot dithering (order 3 - 6x6 matrix)</option>
                      <option value="cluster8">Ordered clustered dot dithering (order 4 - 8x8 matrix)</option>
                      <option value="cluster16">Ordered clustered dot dithering (order 8 - 16x16 matrix)</option>
                    </select>
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="importFile">Select PNG file:</label>
                    <input type="file" id="importFile" accept=".png, .bmp" />
                  </div>
                </div>
              </div>
              <div class="selected-image" style="height: 330px;" id="selectedImagePanel">
                <img id="selectedImage" src="" />
              </div>
            </div>
            <div id="transparentColorsTab" class="tab-content">
              <table class="transparent-colors">
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
              </table>
            </div>
          </td>
          <td style="vertical-align: top; width: 30%;">
            <div class="preview-panel" id="importedItemsPanel"></div>
          </td>
        </tr>
      </table>
      <div class="form-actions">
        <button id="importPreview" style="display: none;">Preview</button>
        <button id="importImport" style="display: none;">Import</button>
        <button id="importClose">Close</button>
      </div>
    </div>
  </div>

  <!-- Overlay: validation message -->
  <div id="validationOverlay" class="overlay">
    <div id="validationDialog" class="dialog">
      <p id="validationMessage"></p>
      <button id="validationOk">OK</button>
    </div>
  </div>

  <!-- Overlay: invalid image message -->
  <div id="invalidImageOverlay" class="overlay">
    <div id="invalidImageDialog" class="dialog">
      <p>Invalid image</p>
      <button id="invalidImageOk">OK</button>
    </div>
  </div>

  <!-- Overlay: export dialog -->
  <div id="exportDialogOverlay" class="overlay">
    <div id="exportDialog" class="dialog export-dialog">
      <table style="width: 100%; height: 100%;">
        <tr>
          <td style="height: 50px;">
            <div class="header" id="exportDialogHeader"></div>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top; display: flex;">
            <div class="export-container">
              <div class="zoom-controls">
                <button id="zoomIn">Zoom In</button>
                <button id="zoomOut">Zoom Out</button>
              </div>
              <textarea id="exportText" style="height: 550px;" class="export-text" readonly></textarea>
            </div>
          </td>
        </tr>
        <tr>
          <td style="height: 50px;">
            <div class="form-actions">
              <button id="exportCopy">Copy</button>
              <button id="exportClose">Close</button>
            </div>
          </td>
        </tr>
      </table>
    </div>
  </div>

  <!-- Code Generator Modal -->
  <div id="codeGeneratorModal" class="overlay">
    <div class="dialog" style="width: 800px;height:600px;">
      <div class="filter-container">
        <label for="targetSelect">Target:</label>
        <select id="targetSelect">
          <option value="MSX">MSX</option>
          <option value="MSX2">MSX2</option>
          <option value="MSX2+">MSX2+</option>
          <!-- <option value="MSX Turbo-R">MSX Turbo-R</option> -->
          <!--  <option value="V9990">V9990</option> -->
        </select>
        <label for="screenModeSelect">Screen mode:</label>
        <select id="screenModeSelect"></select>
        <label for="codePaletteSelect">Palette:</label> <!-- Changed id here -->
        <select id="codePaletteSelect"></select> <!-- Changed id here -->
        <div style="margin-left: auto;">
          <button id="codeGeneratorWrite">Write</button>
          <button id="codeGeneratorCancelTop">Cancel</button>
        </div>
      </div>
      <div class="grid-container">
        <table id="filteredGrid">
          <thead>
            <tr>
              <th>Select</th>
              <th>ID</th>
              <th>Description</th>
              <th>Type</th>
              <th>Subtype</th>
              <th>Font Mode</th>
            </tr>
          </thead>
          <tbody>
            <!-- Filtered elements will be populated dynamically -->
          </tbody>
        </table>
      </div>
      <div class="form-actions">
        <button id="codeGeneratorCopy">Copy</button>
        <button id="codeGeneratorWrite">Write</button>
        <button id="codeGeneratorCancelTop">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Overlay: image dialog -->
  <div id="imageDialogOverlay" class="overlay">
    <div class="dialog image-dialog">
      <div class="header" id="imageDialogHeader"></div>
      <div class="image-container" style="width: 750px; height: 600px;">
        <img id="combinedImage"  src="" style="image-rendering: pixelated;"/>
      </div>
      <div class="form-actions">
        <button id="imageDialogCopy">Copy</button>
        <button id="imageDialogClose">Close</button>
      </div>
    </div>
  </div>

  <script>

    const wasmUri = 'WASM_URI_PLACEHOLDER';
    let freeImageModuleIsReady=false;
  </script>
<script  src="utils_js_URI"></script>
<script  src="thiefColor_js_URI"></script>
<script  src="MSXimgLib_js_URI"></script>
<!-- Includi la libreria utils.js come script classico con il nonce -->
  
  
<script >


//let freeImageModule = null;
//
//createModule().then((Module) => {
//    freeImageModule = Module;
//    console.log('WebAssembly module initialized.');
//
//    // Opzionale: Invia un evento per segnalare che il modulo è pronto
//    document.dispatchEvent(new Event('FreeImageModuleReady'));
//}).catch((err) => {
//    console.error('Error initializing WebAssembly module:', err);
//});
/* ======================================================================================
   GLOBAL STATE
   ====================================================================================== */ 
let editModeActive = false; // if true => hide buttons in grid
let dataStore = [];
let tempPaletteColors = []; // Global variable to store temporary colors
const vscode = acquireVsCodeApi(); // Acquire VS Code API once
let importSpecs = {};
let croppedImages = []; // Global array to store cropped images
let importPreviewImages = [];
let importPreviewPalette = [];
let importPaletteID = -1;
let importPalette = []; // Global variable to store the palette used for import
let thiefMaxColors=15;
let croppedImportImages = []; 
let noCroppedImportImages = [];
let codeGeneratorItems = [];
let codGeneratorMachine="";
let codeGeneratorScreenMode="";
let noCroppedImageColorCounter=0;
let croppedImageColorCounter=0;

/* ======================================================================================
   MOCK DATA
   ====================================================================================== */

function loadDataStore(data) {
  dataStore = JSON.parse(data);
 

  // Set the export language combo box value
  const exportLanguageSelect = document.getElementById("exportLanguageSelect");
  const settingExportType = dataStore.find(r => r.Type === "SETTING_EXPORT_TYPE");
  if (settingExportType) {
    exportLanguageSelect.value = settingExportType.Values;
  } else {
    dataStore.push({ Type: "SETTING_EXPORT_TYPE", Values: "c" });
    exportLanguageSelect.value = "c";
  }
  updateGrid();
}

/* ======================================================================================""
   SUPPORT FUNCTIONS
   ====================================================================================== */

function saveDataStore() {
  vscode.postMessage({
    command: 'saveDataStore',
    data: JSON.stringify(dataStore)
  });
}

/* ======================================================================================
   SUPPORT FUNCTIONS
   ====================================================================================== */

function getSubtypesForType(type) {
  if (type === "Sprites") {
    return ["Type 1", "Type 2"];
  }
 else if (type === "Tiles") {
   return ["Bitmap","Standard"];
 }
  return [];
}

function getDependants(type, id) {
  return dataStore.filter(r => (r.ChildObjectType === type && r.ChildObjectID && r.ChildObjectID.toString() === id.toString()));
}

function getNextIDForType(type) {
  let max = 0;
  dataStore.forEach(r => {
    if (r.Type === type && r.ID > max) {
      max = r.ID;
    }
  });
  return max + 1;
}

function getChildObjectDescription(childType, childID) {
  if (!childType || !childID) return "";
  
  let rec= dataStore.find(r => r.Type === childType && r.ID.toString() === childID.toString());
  
  if (!rec) return "";
  return rec.Description;
}

/* ======================================================================================
   SUBTYPE + GRID MANAGEMENT
   ====================================================================================== */
function updateSubtypeCombo() {
  const type = document.getElementById("typeSelect").value;
  const subtypeCombo = document.getElementById("subtypeSelect");
  const subtypeLabel = document.getElementById("subtypeLabel");

  let subtypes = getSubtypesForType(type);
  if (subtypes.length > 0) {
    subtypeCombo.classList.remove("hidden");
    subtypeLabel.classList.remove("hidden");
    subtypeCombo.innerHTML = "";
    subtypes.forEach(st => {
      let opt = document.createElement("option");
      opt.value = st;
      opt.textContent = st;
      subtypeCombo.appendChild(opt);
    });
    subtypeCombo.selectedIndex = 0;
  } else {
    subtypeCombo.classList.add("hidden");
    subtypeLabel.classList.add("hidden");
    subtypeCombo.innerHTML = "";
  }
}

function updateGrid() {
  const type = document.getElementById("typeSelect").value;
  const subtypeCombo = document.getElementById("subtypeSelect");
  let subtype = "";
  if (!subtypeCombo.classList.contains("hidden")) {
    subtype = subtypeCombo.value;
  }
  renderGrid(type, subtype);
}

/* ======================================================================================
   RENDER GRID
   ====================================================================================== */
function renderGrid(typeFilter, subtypeFilter) {
  const tbody = document.querySelector("#dataGrid tbody");
  const theadRow = document.getElementById("gridHeader");
  tbody.innerHTML = "";
  theadRow.innerHTML = "";
  if(dataStore===null){
    return;
  }
  let columns = [];
  switch (typeFilter) {
    case "Sprites":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }, // New column
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
    case "Tiles":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }, // New column
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
    case "Maps":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Tile", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }, // New column
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
    case "Fonts":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Spaces (W/H)", field: "FontSpaces" },
        { label: "First char", field: "FirstFontChar" },
        { label: "Last char", field: "LastFontChar" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }, // New column
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
    case "Animations":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Sprite/Tile", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }
      ];
      break;
    case "Palettes":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Colors", field: "Values" },
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
    case "Images":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" }, // New column
        { label: "Code tag ID", field: "TagName" } // New column
      ];
      break;
  }

  // Create the header
  columns.forEach(col => {
    let th = document.createElement("th");
    th.textContent = col.label;
    theadRow.appendChild(th);
  });
  let thAction = document.createElement("th");
  thAction.textContent = "Actions";
  theadRow.appendChild(thAction);

  // Filter dataStore
  let filteredData = dataStore.filter(row => {
    if (row.Type !== typeFilter) return false;
    if (getSubtypesForType(typeFilter).length > 0) {
      return (row.Subtype === subtypeFilter);
    }
    return (row.Subtype === "");
  });

  // Rows
  filteredData.forEach(row => {
    let tr = document.createElement("tr");

    columns.forEach(col => {
      let td = document.createElement("td");

      if (col.field === "ChildObjectID") {
        // get the description of the child object
        let objDesc = getChildObjectDescription(row.ChildObjectType, row.ChildObjectID);
        // if Animations => add (S) or (T)
        if (typeFilter === "Animations") {
          if (row.ChildObjectType === "Sprites") {
            objDesc += " (Sprite)";
          } else if (row.ChildObjectType === "Tiles") {
            objDesc += " (Tile)";
          }
        }
        td.textContent = objDesc;
      }
      else if (col.field === "Values" && typeFilter === "Palettes") {
        // 16 squares
        try {
          
          let valArr =row.Values;
          valArr.forEach(c => {
            let colorDiv = document.createElement("span");
            colorDiv.className = "color-square";
            let hexID = (c.id + "").toUpperCase();
            if (hexID === "0") {
              colorDiv.classList.add("checkerboard");
              colorDiv.style.cursor = "default";
            } else {
              colorDiv.style.backgroundColor = c.color;
            }
            colorDiv.title = `RGB: ${c.color}\nMSX: ${rgbToMsx(c.color)}`;

            let labelSpan = document.createElement("span");
            labelSpan.textContent = hexID;
            let isDark = computeBrightness(c.color) < 128;
            labelSpan.style.color = isDark ? "#fff" : "#000";
            if (hexID === "0") {
              labelSpan.style.color = "#444";
            }
            colorDiv.appendChild(labelSpan);
            td.appendChild(colorDiv);
          });
        } catch(e) {
          td.textContent = "Invalid JSON Colors";
        }
      }
      else if (col.field === "ValuesCount") {
        // New column logic
        td.textContent = row.Values ? row.Values.length : 0;
      }
      else if (typeFilter === "Fonts" && col.field === "FontSpaces") {
        // If FontSpaces is empty => "0x0"
        if (!row.FontSpaces) {
          td.textContent = "0x0";
        } else {
          td.textContent = row.FontSpaces;
        }
      }
      else {
        // generic
        td.textContent = row[col.field] || "";
      }

      tr.appendChild(td);
    });

    // Actions column
    const expLanguageSelect = document.getElementById("exportLanguageSelect");
    let tdActions = document.createElement("td");
    if (!editModeActive) {
      // Edit button
      let editBtn = document.createElement("button");
      editBtn.className = "action-button";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", () => {
        openEditDialog(row, false);
      });
      tdActions.appendChild(editBtn);

      // Remove button
      let removeBtn = document.createElement("button");
      removeBtn.className = "action-button";
      removeBtn.textContent = "Remove";
      let isRef = getDependants(row.Type, row.ID).length > 0;
      if (isRef) {
        removeBtn.style.display = "none";
      }
      // if Palettes => do not remove if there is only 1
      let totalPal = dataStore.filter(r => r.Type === "Palettes").length;
      if (row.Type === "Palettes" && totalPal <= 1) {
        removeBtn.style.display = "none";
      }
      removeBtn.addEventListener("click", () => {
        if(row.Type === "Sprites" || row.Type === "Tiles"){
          let dependants = getDependants(row.Type, row.ID);
          if(dependants.length > 0){
            openInfoDialog("You can't remove the record because it is used by \"" + dependants[0].Name + "\" " + dependants[0].Type, null);
            return;
          }
          
        }
        openConfirmDialog(() => {
          dataStore = dataStore.filter(r => !(r.Type === row.Type && r.ID === row.ID));
          saveDataStore();
          updateGrid();
        });
      });
      tdActions.appendChild(removeBtn);

      // Import button
      if ((row.Type === "Sprites" && row.Subtype=="Type 1") || (row.Type === "Tiles" && row.Subtype=="Bitmap") || row.Type === "Fonts" || row.Type === "Images" ) {
        let importBtn = document.createElement("button");
        importBtn.className = "action-button imports-button";
        importBtn.textContent = "Import...";
        importBtn.dataset.recordId = row.ID;
        tdActions.appendChild(importBtn);
      }

      // Details button (except Palettes)
      if (row.Type !== "Palettes" && row.ChildObjectID !== "-1") {
        let detailsBtn = document.createElement("button");
        detailsBtn.className = "action-button details-button";
        detailsBtn.textContent = "Collection...";
        detailsBtn.dataset.recordId = row.ID;
        tdActions.appendChild(detailsBtn);
      }

      // Export button (except Animations)
      if (row.Type !== "Animations" && row.Values && row.Values.length > 0) {
        let exportBtn = document.createElement("button");
        exportBtn.className = "action-button export-button";
        exportBtn.textContent = "Export...";
        exportBtn.dataset.recordId = row.ID;
        tdActions.appendChild(exportBtn);
      }

      // Get image button
      if (["Sprites", "Fonts", "Images", "Tiles"].includes(typeFilter)) {
        let btnGetImage = document.createElement("button");
        btnGetImage.textContent = "Get image...";
        btnGetImage.className = "action-button getimage-button";
        btnGetImage.addEventListener("click", () => {
          
        const paletteRecord = dataStore.find(r => r.Type === "Palettes" && r.ID.toString() === row.ChildObjectID.toString());
        createCombinedImage(row, paletteRecord,true);
        document.getElementById("imageDialogHeader").textContent = `${typeFilter} set "${row.Description}"`;
        document.getElementById("imageDialogHeader").style.fontWeight = "bold";
        document.getElementById("imageDialogHeader").style.fontSize = "20px";
        document.getElementById("imageDialogOverlay").style.display = "flex";
        });
        tdActions.appendChild(btnGetImage);
      }
      // Code sync button


      if (row.Type !== "Animations" ){
        if(expLanguageSelect.value==="c" || expLanguageSelect.value.toString().substring(0,3)==="asm"){
          let codeUpdateBtn = document.createElement("button");
          codeUpdateBtn.className = "action-button codesync-button";
          codeUpdateBtn.textContent = "Code synch";
          codeUpdateBtn.dataset.recordId = row.ID;
          tdActions.appendChild(codeUpdateBtn);
        }
      }
      
    }
    tr.appendChild(tdActions);

    tbody.appendChild(tr);
  });
}

/* ======================================================================================
   OPEN EDIT DIALOG
   ====================================================================================== */
function openEditDialog(existingRow, createNew) {
  const dialog = document.getElementById("editDialog");
  dialog.innerHTML = "";
  dialog.classList.remove("hidden");

  // Hide "New" button
  document.getElementById("addButton").classList.add("hidden");

  editModeActive = true;
  updateGrid();

  // Disable Type and Subtype
  document.getElementById("typeSelect").disabled = true;
  document.getElementById("subtypeSelect").disabled = true;

  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }

  let tempRow = {};
  if (createNew) {
    tempRow.Type = currentType;
    tempRow.Subtype = getSubtypesForType(currentType).length > 0 ? currentSubtype : "";
    tempRow.ID = getNextIDForType(currentType);
    tempRow.Description = "";
    tempRow.Size = "";
    tempRow.EditingSettings = "";
    tempRow.ChildObjectType = "";
    tempRow.ChildObjectID = null;
    tempRow.Values = "";
    tempRow.FirstFontChar = "";
    tempRow.LastFontChar = "";
    tempRow.FontSpaces = "";
    tempRow.msxglSpriteSize = "bmp"; // Default value for new records
    tempRow.TagName = ""; // Initialize TagName

    // if Palettes => default colors
    if (currentType === "Palettes") {
      tempRow.Values = getDefaultMSXColors(false);
      tempPaletteColors = [...tempRow.Values]; // Assign initial palette
    }
    // if Sprites => size=8x8
    if (currentType === "Sprites") {
      tempRow.Size = "8x8";
    }
    // if Tiles and subtype=Bitmap => size=8x8
    if (currentType === "Tiles" && currentSubtype === "Bitmap") {
      tempRow.Size = "8x8";
    }
    // if Images => size=100x100
    if (currentType === "Images") {
      tempRow.Size = "100x100";
    }
    // if Fonts => size=8x8
    if (currentType === "Fonts") {
      tempRow.Size = "8x8";
      tempRow.FontSpaces = "0x0";
    }
    if (currentType === "Maps") {
      tempRow.Size = "10x10";
    }

    
  } else {
    // Shallow copy
    tempRow = { ...existingRow };
    if (currentType === "Palettes") {
      tempPaletteColors = [...tempRow.Values]; // Assign existing palette
    }
  }

  let fields = getFieldsForType(currentType, tempRow, createNew);
  fields.forEach(f => {
    let divWrap = document.createElement("div");
    divWrap.className = "form-group";
    let fieldLabel = document.createElement("label");
    fieldLabel.textContent = f.label;
    let fieldInput = null;

    switch (f.type) {
      case "text":
        fieldInput = document.createElement("input");
        fieldInput.type = "text";
        fieldInput.value = tempRow[f.name] || "";
        if (f.maxLength) {
          fieldInput.maxLength = f.maxLength;
        }
        fieldInput.disabled = !!f.disabled;
        fieldInput.addEventListener("input", e => {
          tempRow[f.name] = e.target.value;
        });
        break;

      case "spinpair":
      case "spinpair-fontspaces":
        let [w, h] = (tempRow[f.name] || "0x0").split("x");
        let spinW = document.createElement("input");
        spinW.type = "number";
        spinW.min = f.min; spinW.max = f.max; spinW.step = f.step;
        spinW.value = w || 0;
        spinW.disabled = !!f.disabled;

        let spinH = document.createElement("input");
        spinH.type = "number";
        spinH.min = f.min; spinH.max = f.max; spinH.step = f.step;
        spinH.value = h || 0;
        spinH.disabled = !!f.disabled;

        spinW.addEventListener("change", () => {
          tempRow[f.name] = spinW.value + "x" + spinH.value;
          
        });
        spinH.addEventListener("change", () => {
        
          tempRow[f.name] = spinW.value + "x" + spinH.value;
          
        });

        fieldInput = document.createElement("span");
        fieldInput.appendChild(spinW);
        fieldInput.appendChild(document.createTextNode(" x "));
        fieldInput.appendChild(spinH);
        break;

      case "char":
        fieldInput = document.createElement("input");
        fieldInput.type = "text";
        fieldInput.maxLength = 1;
        fieldInput.value = tempRow[f.name] || "";
        fieldInput.disabled = !!f.disabled;
        fieldInput.addEventListener("input", e => {
          if (e.target.value.length > 1) {
            e.target.value = e.target.value.slice(0,1);
          }
          tempRow[f.name] = e.target.value;
        });
        break;

      case "combobox":
        fieldInput = document.createElement("select");
        fieldInput.disabled = !!f.disabled;
        f.options.forEach(opt => {
          let o = document.createElement("option");
          o.value = opt.value;
          o.textContent = opt.label;
          fieldInput.appendChild(o);
        });
        fieldInput.value = tempRow[f.name] || "";
        fieldInput.addEventListener("change", e => {
          tempRow[f.name] = e.target.value;
        });
        break;

      case "palette-colors-editor":
        fieldInput = document.createElement("div");
        renderPaletteEditor(fieldInput, tempRow);
        break;
    }

    divWrap.appendChild(fieldLabel);
    if (fieldInput) divWrap.appendChild(fieldInput);
    dialog.appendChild(divWrap);
  });

  // Add msxglSpriteSize field if Type is "Sprites" and Subtype is "Type 1"
  if (currentType === "Sprites" && currentSubtype === "Type 1") {
    let divWrap = document.createElement("div");
    divWrap.className = "form-group";
    let fieldLabel = document.createElement("label");
    fieldLabel.textContent = "Export mode:";
    let fieldInput = document.createElement("select");
    fieldInput.innerHTML = '<option value="bmp">Bitmap</option><option value="gm1">Graphic mode 1 (Screen 1)</option><option value="gm2">Graphic mode 2 (Screen 2 or 4)</option><option value="sprt">16x16 sprites with specific block ordering</option>';
    fieldInput.value = tempRow.msxglSpriteSize || "bmp";
    fieldInput.addEventListener("change", e => {
      tempRow.msxglSpriteSize = e.target.value;
    });
    divWrap.appendChild(fieldLabel);
    divWrap.appendChild(fieldInput);
    dialog.appendChild(divWrap);
  }

  if (currentType !== "Animations" && !createNew) {
    // Add TagName field
    let divWrapTagName = document.createElement("div");
    divWrapTagName.className = "form-group";
    let fieldLabelTagName = document.createElement("label");
    fieldLabelTagName.textContent = "Code tag ID:";
    let fieldInputTagName = document.createElement("input");
    fieldInputTagName.type = "text";
    fieldInputTagName.maxLength = 30;
    fieldInputTagName.value = tempRow.TagName || "";
    fieldInputTagName.addEventListener("input", e => {
      e.target.value = e.target.value.replace(/[^a-zA-Z0-9_]/g, '');
      tempRow.TagName = e.target.value;
    });
    divWrapTagName.appendChild(fieldLabelTagName);
    divWrapTagName.appendChild(fieldInputTagName);
    dialog.appendChild(divWrapTagName);
  }
  // Save/Cancel buttons
  let divActions = document.createElement("div");
  divActions.className = "form-group";
  let saveBtn = document.createElement("button");
  saveBtn.textContent = "Save";
  saveBtn.addEventListener("click", () => {
    

    // If Animations in edit mode => user can only change description
    if (currentType === "Animations" && !createNew) {
      tempRow.ChildObjectID = existingRow.ChildObjectID;
      tempRow.ChildObjectType = existingRow.ChildObjectType;
    }

    // Minimum validation
    if (!tempRow.Description) {
      openInfoDialog("Description is required.", null);
      return;
    }

    // Validate TagName
    if (tempRow.Type!=="Animations") {
      if(!tempRow.TagName || tempRow.TagName.trim()===""){
        openInfoDialog("Code tag ID is required.", null);
        return;
      }
      if (!checkTagName(dataStore, tempRow)) {
        openInfoDialog("Code tag ID must be unique.", null);
        return;
      }
      const num = Number(tempRow.TagName.toString().substring(0,1));
      if(!isNaN(num)){
        openInfoDialog("Code tag ID must not start with a number.", null);
        return;
      }
    }
    else{
      tempRow.TagName="_";
    }
    

    // Example of size validations
    if (!checkSizeConstraints(currentType, currentSubtype, tempRow)) {
      return;
    }

    // Animations createNew => "childID_suffix"
    if (currentType === "Animations" && createNew) {
      let rawVal = tempRow.ChildObjectID || "";
      let parts = rawVal.split("_");
      if (parts.length === 2) {
        let childID = parseInt(parts[0], 10);
        let suffix = parts[1];
        if (suffix === "S") {
          tempRow.ChildObjectType = "Sprites";
        } else if (suffix === "T") {
          tempRow.ChildObjectType = "Tiles";
        } else {
          openInfoDialog("Invalid suffix in Sprite/Tile combo.", null);
          return;
        }
        tempRow.ChildObjectID = childID;
      } else {
        openInfoDialog("Please select a valid Sprite/Tile in combo.", null);
        return;
      }
    }

    // Other types => ChildObjectType based on rules
    if (!createNew && currentType === "Animations") {
      // do nothing
    } else if (["Sprites","Tiles","Fonts","Images"].includes(currentType)) {
      tempRow.ChildObjectType = "Palettes";
    } else if (currentType === "Maps") {
      tempRow.ChildObjectType = "Tiles";
    }

    // Required fields validation
    let requiredFields = getRequiredFieldsForType(currentType);
    for (let field of requiredFields) {
      if (tempRow[field] === undefined || tempRow[field] === null || tempRow[field] === "") {
        openInfoDialog(`${getFieldNames(currentType, field)} is required!`, null);
        return;
      }
    }

    // Validate msxglSpriteSize if set to "16x16"
    if (currentType === "Sprites" && currentSubtype === "Type 1" && tempRow.msxglSpriteSize === "sprt") {
      let [w, h] = tempRow.Size.split("x").map(Number);
      if (w % 16 !== 0 || h % 16 !== 0) {
        openInfoDialog("16x16 export mode is not compatible with sprite set size", null);
        return;
      }
    }
   
    // Save
    if (createNew) {
      if (createNew && currentType !== "Palettes" && currentType !== "Animations") {
          
        tempRow.EditingSettings={
          "GridEditorZoom":currentType === "Images"?0.1:1.25,
          "ObjectsGridZoom":3,
          "ObjectsGridBackgroundColor":"#010101",
          "PatternsGridZoom":1,
          "PatternGridBackgroundColor":"#010101",
          "PreviewZoom":3,
          "PreviewdBackgroundColor":"#010101",
          "GridEditorZoom":3,
          "ShowGrid":true,
          "Show8x8Blocks":true
        };

        
        

  
        
      }
      dataStore.push(tempRow);
    } else {
      let idx = dataStore.findIndex(r => r.Type === existingRow.Type && r.ID === existingRow.ID);
      if (idx >= 0) {
        dataStore[idx] = tempRow;
      }
    }

    saveDataStore();
    dialog.classList.add("hidden");
    document.getElementById("typeSelect").disabled = false;
    document.getElementById("subtypeSelect").disabled = false;
    editModeActive = false;
    updateGrid();

    // Show "New" button
    document.getElementById("addButton").classList.remove("hidden");
  });
  divActions.appendChild(saveBtn);

  let cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    dialog.classList.add("hidden");
    document.getElementById("typeSelect").disabled = false;
    document.getElementById("subtypeSelect").disabled = false;
    editModeActive = false;
    updateGrid();

    // Show "New" button
    document.getElementById("addButton").classList.remove("hidden");
  });
  divActions.appendChild(cancelBtn);

  dialog.appendChild(divActions);
}

/* ======================================================================================
   SIZE VALIDATION FUNCTION
   ====================================================================================== */
function checkSizeConstraints(type, subtype, row) {
  if (!row.Size) return true;

  let [w, h] = row.Size.split("x");
  let wNum = parseInt(w, 10) || 0;
  let hNum = parseInt(h, 10) || 0;

  if (type === "Sprites" || subtype=== "Type 2") {
    // Sprites validation (already present)
    if (wNum < 8 || wNum > 16 || hNum < 8 || hNum > 16) {
      openInfoDialog("Size must be in [8.16].", null);
      return false;
    }
    if ((wNum !== hNum) ) {
      openInfoDialog("Size must be 8x8 or 16x16", null);
      return false;
    }
  }

  if (type === "Sprites" || type=== "Tiles") {
    // Sprites validation (already present)
    if (wNum < 8 || wNum > 32 || hNum < 8 || hNum > 32) {
      openInfoDialog("Size must be in [8.32].", null);
      return false;
    }
    if (wNum % 8 !== 0 || hNum % 8 !== 0) {
      openInfoDialog("Size must be multiples of 8", null);
      return false;
    }
  }
  else if (type === "Tiles" ) { //&& subtype === "Bitmap"
    // Tiles bitmap validation (already present)
    if (wNum < 4 || wNum > 64 || hNum < 4 || hNum > 64) {
      openInfoDialog("Tiles Bitmap size must be in [4..64]", null);
      return false;
    }
  }
  else if (type === "Images") {
    if (wNum > 256 || wNum < 30 ) {
      openInfoDialog("Images width size must be in [30..256]", null);
      return false;
    }
    if (hNum > 212 ||hNum < 30) {
      openInfoDialog("Images height size must be in [30..212]", null);
      return false;
    }

  }
  else if (type === "Fonts") {
    // REQUEST: minimum size 50x50, maximum 1024x512
    if (wNum > 20 || hNum > 20 || wNum < 8 || hNum < 8) {
      openInfoDialog("Fonts size must be in [8..20]", null);
      return false;
    }
  }
  else if (type === "Maps") {
    // REQUEST: minimum size 50x50, maximum 1024x512
    if (wNum > 100 || hNum > 100 || wNum < 2 || hNum < 2) {
      openInfoDialog("Maps size must be in [2..100]", null);
      return false;
    }
  }
  return true;
}

/* ======================================================================================
   getFieldsForType
   ====================================================================================== */
function getFieldsForType(type, row, createNew) {
  let fields = [
    { label: "ID: ", name: "ID", type: "text", disabled: true },
    { label: "Description: ", name: "Description", type: "text", maxLength: 255 }
  ];
  if (type !== "Animations") {
    fields.push({ label: "Code tag ID: ", name: "TagName", type: "text", maxLength: 30 });
  }
  if (type === "Sprites") {
    let sizeOptions = { min: 8, max: 64, step: 8, disabled: !createNew };
    if (row.Subtype === "Type 2") {
      sizeOptions = { min: 8, max: 16, step: 8, disabled: !createNew };
    }
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      ...sizeOptions
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Tiles") {
    let isStandard = (row.Subtype === "Standard");
    let sizeDisabled = false;
    let step = 1;
    let minVal = 1;
    let maxVal = 64;

    if (!createNew) {
      sizeDisabled = true;
    } else {
      sizeDisabled = isStandard;
      if (isStandard && !row.Size) {
        row.Size = "8x8";
      }
    }
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: minVal,
      max: maxVal,
      step: step,
      disabled: sizeDisabled
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Maps") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 64,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Tile: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getTileOptions(),
      disabled: false
    });
  }
  else if (type === "Fonts") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 20,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Spaces (W/H): ",
      name: "FontSpaces",
      type: "spinpair-fontspaces",
      min: 1,
      max: 20,
      step: 1,
      disabled: false
    });
    fields.push({
      label: "First character: ",
      name: "FirstFontChar",
      type: "char",
      disabled: false
    });
    fields.push({
      label: "Last character: ",
      name: "LastFontChar",
      type: "char",
      disabled: false
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Palettes") {
    fields.push({
      label: "Colors: ",
      name: "Values",
      type: "palette-colors-editor"
    });
  }
  else if (type === "Images") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 512,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Animations") {
    // if createNew => combo, if edit => no combo
    if (createNew) {
      fields.push({
        label: "Sprite/Tile: ",
        name: "ChildObjectID",
        type: "combobox",
        options: getSpriteTileOptionsWithSuffix(),
        disabled: false
      });
    }
  }

  return fields;
}

/* ======================================================================================
   COMBO UTILS
   ====================================================================================== */

function getPaletteOptions(includeNotSelected = false) {
  let list = dataStore.filter(r => r.Type === "Palettes");
  let options = list.map(r => ({ value: r.ID, label: r.Description }));
  if (includeNotSelected) {
    options.unshift({ value: -1, label: "Not selected" });
  }
  return options;
}

function getTileOptions() {
  let list = dataStore.filter(r => r.Type === "Tiles");
  return list.map(r => ({ value: r.ID, label: r.Description }));
}

function getSpriteTileOptionsWithSuffix() {
  // for Animations => "ID_S" or "ID_T"
  let list = dataStore.filter(r => r.Type === "Sprites" || r.Type === "Tiles");
  return list.map(r => {
    let suffix = (r.Type === "Sprites") ? "S" : "T";
    let labelSuffix = (r.Type === "Sprites") ? "(Sprite)" : "(Tile)";
    return {
      value: r.ID + "_" + suffix,
      label: r.Description + " " + labelSuffix
    };
  });
}

/* ======================================================================================
   EDITOR OF "PALETTE-COLORS-EDITOR"
   ====================================================================================== */
function renderPaletteEditor(container, tempRow) {
  let paletteArray = [];
  if (tempRow.Values) {
    try {
      paletteArray = tempRow.Values;
    } catch (e) {
      paletteArray = getDefaultMSXColors(false);
    }
  } else {
    paletteArray = getDefaultMSXColors(false);
  }
  tempPaletteColors = [...paletteArray]; // Copy colors to global variable

  tempPaletteColors.forEach(colObj => {
    let box = document.createElement("span");
    box.className = "color-square";
    let colorCode = colObj.color.toUpperCase();
    let hexID = (colObj.id + "").toUpperCase();
    box.title = `RGB: ${colorCode}\nMSX: ${rgbToMsx(colorCode)}`;

    if (hexID === "0") {
      box.classList.add("checkerboard");
      box.style.cursor = "default";
    } else {
      box.style.backgroundColor = colorCode;
      box.addEventListener("click", () => {
        openColorPickerDialog(colorCode, newColor => {
          colObj.color = newColor;
          box.style.backgroundColor = newColor;
          let labelSpan = box.querySelector("span");
          let isDark = computeBrightness(newColor) < 128;
          labelSpan.style.color = isDark ? "#fff" : "#000";
          // Update the tooltip with the new color
          box.title = `RGB: ${newColor}\nMSX: ${rgbToMsx(newColor)}`;
        });
      });
    }

    let labelSpan = document.createElement("span");
    labelSpan.textContent = hexID;
    let isDark = computeBrightness(colorCode) < 128;
    labelSpan.style.color = isDark ? "#fff" : "#000";
    if (hexID === "0") {
      labelSpan.style.color = "#444";
    }
    box.appendChild(labelSpan);

    container.appendChild(box);
  });
}

function getDefaultMSXColors(isMSX2) {
  if(isMSX2){
    return [
      { id: "0", color: "#000000" },
      { id: "1", color: "#010101" },
      { id: "2", color: "#21C842" },
      { id: "3", color: "#5EDC78" },
      { id: "4", color: "#5455ED" },
      { id: "5", color: "#7D76FC" },
      { id: "6", color: "#D4524D" },
      { id: "7", color: "#42EBF5" },
      { id: "8", color: "#FC5554" },
      { id: "9", color: "#FF7978" },
      { id: "A", color: "#D4C154" },
      { id: "B", color: "#E6CE80" },
      { id: "C", color: "#21B03B" },
      { id: "D", color: "#C95BBA" },
      { id: "E", color: "#CCCCCC" },
      { id: "F", color: "#FFFFFF" }
    ];
  }
  else{
    return [
      { id: "0", color: "#000000" },
      { id: "1", color: "#010101" },
      { id: "2", color: "#3EB849" },
      { id: "3", color: "#74D07D" },
      { id: "4", color: "#5955E0" },
      { id: "5", color: "#8076F1" },
      { id: "6", color: "#B95E51" },
      { id: "7", color: "#65DBEF" },
      { id: "8", color: "#DB6559" },
      { id: "9", color: "#FF897D" },
      { id: "A", color: "#CCC35E" },
      { id: "B", color: "#DED087" },
      { id: "C", color: "#3AA241" },
      { id: "D", color: "#B766B5" },
      { id: "E", color: "#CCCCCC" },
      { id: "F", color: "#FFFFFF" }
    ];
  }
}

/* ======================================================================================
   COLOR PICKER
   ====================================================================================== */
function openColorPickerDialog(initialColor, callback) {

  const overlay = document.getElementById("colorPickerOverlay");
  const colorInput = document.getElementById("colorPickerInput");
  const okBtn = document.getElementById("colorPickerOk");
  const cancelBtn = document.getElementById("colorPickerCancel");

  overlay.style.display = "flex";
  colorInput.value = rgbToHex(initialColor);

  function onOk() {
    let newColor = colorInput.value.toUpperCase();
    if(newColor==="#000000"){
      newColor="#010101";
    }
    callback(newColor);
    closeColorPickerOverlay();
  }

  function onCancel() {
    closeColorPickerOverlay();
  }

  function closeColorPickerOverlay() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);

  }

  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);

  // Detect color under mouse pointer
  overlay.addEventListener("mousemove", (e) => {
    const color = getColorAtMousePosition(e.clientX, e.clientY);
    if (color) {
      colorInput.value = rgbToHex(color);
    }
  });
}

function getColorAtMousePosition(x, y) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = 1;
  canvas.height = 1;
  const element = document.elementFromPoint(x, y);
  if (element && (element.tagName === "IMG" || element.tagName === "CANVAS")) {
    context.drawImage(element, -x, -y);
    const pixel = context.getImageData(0, 0, 1, 1).data;
    return `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
  }
  return null;
}

function focusOnColorSquare() {
  const colorSquare = document.querySelector('.color-square[style*="background-color"]');
  if (colorSquare) {
    colorSquare.focus();
  }
}

/* ======================================================================================
   CONFIRM DIALOG
   ====================================================================================== */
function openConfirmDialog(onConfirm) {
  const overlay = document.getElementById("confirmOverlay");
  const okBtn = document.getElementById("confirmOk");
  const cancelBtn = document.getElementById("confirmCancel");

  overlay.style.display = "flex";

  let onOk = () => {
    closeConfirm();
    onConfirm();
  };
  let onCancel = () => {
    closeConfirm();
  };
  function closeConfirm() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);
  }
  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);
}

/* ======================================================================================
   INFO DIALOG
   ====================================================================================== */
function openInfoDialog(message, onClose) {
  const overlay = document.getElementById("infoOverlay");
  const msg = document.getElementById("infoMessage");
  const okBtn = document.getElementById("infoOk");

  msg.textContent = message;
  overlay.style.display = "flex";

  let onOk = () => {
    closeInfo();
    if (onClose) onClose();
  };
  function closeInfo() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
  }
  okBtn.addEventListener("click", onOk);
}

/* ======================================================================================
   COLOR UTILITY
   ====================================================================================== */
function computeBrightness(hex) {
  let c = hex.replace("#","");
  if (c.length < 6) return 255;
  let r = parseInt(c.substring(0,2), 16);
  let g = parseInt(c.substring(2,4), 16);
  let b = parseInt(c.substring(4,6), 16);
  return (0.299*r + 0.587*g + 0.114*b);
}

//function rgbToHex(rgb) {
//  let hex = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
//  function hexify(x) {
//    return ("0" + parseInt(x).toString(16)).slice(-2).toUpperCase();
//  }
//  return "#" + hexify(hex[1]) + hexify(hex[2]) + hexify(hex[3]);
//}

/* ======================================================================================
   EVENT LISTENERS (on load)
   ====================================================================================== */
document.addEventListener("DOMContentLoaded", () => {
  document.getElementById("typeSelect").value = "Sprites";
  updateSubtypeCombo();
  updateGrid();

  document.getElementById("typeSelect").addEventListener("change", () => {
    updateSubtypeCombo();
    updateGrid();
  });
  document.getElementById("subtypeSelect").addEventListener("change", () => {
    updateGrid();
  });

  document.getElementById("addButton").addEventListener("click", () => {
    openEditDialog(null, true);
  });

  // Listen for messages from the extension
  window.addEventListener('message', event => {
    const message = event.data;
    switch (message.command) {
      case 'loadDataStore':
        loadDataStore(message.data);
        break;
      case 'returnFromDetails':
        const data = JSON.parse(message.data);
        // Update the data store with the reloaded data
        dataStore = data;
        // Apply filters based on the record's type and subtype
        applyFilters(message.record.Type, message.record.Subtype);
        // Update the grid with the reloaded data
        updateGrid();
        // Scroll to the specific record
        scrollToRecord(message.record);
        break;
      case 'closeDetailsView':
          //updateRecord(message.record,message.action);
        break;
    }
  });



  document.getElementById("dataGrid").addEventListener("click", (e) => {
    if (e.target.classList.contains("details-button")) {
      const recordId = e.target.dataset.recordId;
      const currentType = document.getElementById("typeSelect").value;
      let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
      const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
      openDetailsView(record);
    }
  });
  document.getElementById("exportLanguageSelect").addEventListener("change", () => {
    updateGrid();
  });
  document.getElementById("dataGrid").addEventListener("click", (e) => {
    if (e.target.classList.contains("imports-button")) {
      
      const recordId = e.target.dataset.recordId;
      const currentType = document.getElementById("typeSelect").value;
      let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
      const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
      openImportDialog(record);
    }
  });

  document.getElementById("dataGrid").addEventListener("click", async (e) => {
    const currentType = document.getElementById("typeSelect").value;
    let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
    const recordId = e.target.dataset.recordId;
 
    const tagName=dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10)).TagName;
    const expLanguageSelect = document.getElementById("exportLanguageSelect");
    if (e.target.classList.contains("codesync-button")) {
      const codeData=await exportRecord(recordId, expLanguageSelect, false);
     
      vscode.postMessage({
        command: "CodeSynch",
        language: expLanguageSelect.value==="c"?"c":"asm",
        data: codeData,
        id: tagName
      });
    }
    
    if (e.target.classList.contains("export-button")) {
      
      
      await exportRecord(recordId, expLanguageSelect, true);
      
    }
});
async function exportRecord(recordId, expLanguageSelect, displayData) {
  const currentType = document.getElementById("typeSelect").value;
      let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
      const record = dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10));

      if(record.Type==="Palettes"){
        let colorId=0;
        let cArray = "";  
        let basicLine=10000;
        if(expLanguageSelect.value==="c"){
          cArray += `const unsigned char ${record.TagName}[] = {\n`;
        }
        else{
          if(expLanguageSelect.value==="msxc"){
            cArray += `TINY colors[] = {\n`;
          }
          else{
            if(expLanguageSelect.value!=="bas"){
              cArray += `${record.TagName}:\n`;
            }
          }
        }
        
        record.Values.forEach(p=>{
          let col=htmlToMSXColor(p.color);
          switch(expLanguageSelect.value) {
            case "c":
              cArray += `\t0x${col[0].toString().toUpperCase()}, 0x${col[1].toString().toUpperCase()}, // Color[${colorId}] ${record.Values[colorId].color} \n`;
              break;
            case "msxc":
              cArray += `\t0x${col[0].split(",").toString().toUpperCase()}, 0x${col[1].toString().toUpperCase()}, /* Color[${colorId}] ${record.Values[colorId].color} */\n`;
              break;
            case "bas":
              basicLine+=10;
              cArray += `${basicLine} DATA &H${col[0].toString().replace("0x","&H")},&H${col[1].toString().replace("0x","&H")} : ' Color[${colorId}] ${record.Values[colorId].color}\n`;
              break;
            case "asm-sdasz80":
              cArray += `\t.db 0x${col[0].toString().toUpperCase()}, 0x${col[1].toString().toUpperCase()}, ; Color[${colorId}] ${record.Values[colorId].color}\n`;
              break;
            case "asm-tniasm":
            case "asm-asmsx":
              cArray += `\tdb $${col[0].toString().toUpperCase().replace("0x","$")}, $${col[1].toString().toUpperCase().replace("0x","$")}, ; Color[${colorId}] ${record.Values[colorId].color}\n`;
              break;
            case "asm-sjasm":       
              cArray += `\tdb 0x${col[0].toString().toUpperCase()}, 0x${col[1].toString().toUpperCase()}, ; Color[${colorId}] ${record.Values[colorId].color} ; Color[${colorId}] ${record.Values[colorId].color}\n`;
              break;
            case "asm-macro80":       
              cArray += `\tdb ${col[0].toString().toUpperCase().replace("0x","")+"h"}, ${col[1].toString().toUpperCase().replace("0x","")+"h"}, ; Color[${colorId}] ${record.Values[colorId].color}\n`;
              break;
          }
          colorId++;


        });
        if(expLanguageSelect.value==="c" || expLanguageSelect.value==="msxc"){
          cArray += `};\n`;
        }
       
        if(displayData){
          openExportDialogPanel(cArray,record);
        }
        return cArray;
      }

      const paletteRecord = dataStore.find(r => r.Type === "Palettes" && r.ID.toString() === record.ChildObjectID.toString());

      if(record.Type==="Maps"){
        const mapData=exportMaps(record,expLanguageSelect.value);
        if(displayData){
          openExportDialogPanel(mapData,record);
        }
        return mapData;
      }
      try {
        const canvas = await createCombinedImage(record, paletteRecord, false);
        const image=canvas.toDataURL();
       
        const exportBase64String = image.split("base64,")[1];
       
        
        let language=expLanguageSelect.value.split("-")[0].toLowerCase();
        let asmType="";
        if(language==="asm"){
          asmType=expLanguageSelect.value.split("-")[1].toLowerCase();
        }
      
        let palettes=[];
        paletteRecord.Values.forEach(p=>{
          palettes.push(parseInt(p.color.substring(1),16));
        });
        

        const [itemWidth, itemHeight] = record.Size.split("x").map(Number);
        const blocksX=canvas.width/itemWidth;
        const blocksY=canvas.height/itemHeight;

        let fontExport=false;
        let fontHeaderFirst=0;
        let fontHeaderLast=0;
        let fontHeaderX=0;
        let fontHeaderY=0;
        let exportType="bmp";
        if (record.Type=="Sprites"){
          exportType=record.msxglSpriteSize;
        }
        if (record.Type=="Fonts"){
          fontExport=true;
          fontHeaderFirst=0;
          fontHeaderLast=0;
          fontHeaderX=0;
          fontHeaderY=0;
        }
        exportType="e"+exportType;
        //console.log("WIDTH",itemWidth);
        //console.log("HEIGHT",itemHeight);
//
        //console.log("BLOCKSX",blocksX);
        //console.log("BLOCKSY",blocksY);
        //console.log("LANGUAGE",language); 
        //console.log("EXPORTTYPE",exportType);
        //console.log("PALETTES",palettes);
       
        if(record.Subtype!="Type 2"){
          const freeImageData=getPngDataArray(exportBase64String,record.TagName,itemWidth*blocksX,itemHeight*blocksY,blocksX,blocksY,"input",0,0,0,0,4,language,false,0,false,0,palettes,16,0,false,false,exportType,"none","none",asmType,"none",null,0,0,0,0,false,fontExport,fontHeaderFirst,fontHeaderLast,fontHeaderX,fontHeaderY,false,false,true);
          console.log("EXPORTIMAGE", freeImageData);
          if(displayData){
            openExportDialogPanel(freeImageData[2],record);
          }
          return freeImageData[2];
        }
        else{
          const arrayc=exportType2Sprites(record,expLanguageSelect.value)
          if(displayData){
            openExportDialogPanel(arrayc,record);
          }
          return arrayc;
        }

        
                                  
        

    
      } catch (error) {
        console.error("Error exporting data:", error);
      }
}
  document.addEventListener("keydown", (e) => {
    if (e.ctrlKey && (e.key === "+" || e.key === "-" || e.key === "=")) {
      e.preventDefault();
      zoomLevel += (e.key === "+" || e.key === "=") ? 0.1 : -0.1;
      zoomLevel = Math.max(0.1, zoomLevel);
      updateZoom();
    }
  });

  document.addEventListener("wheel", (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      zoomLevel += e.deltaY < 0 ? 0.1 : -0.1;
      zoomLevel = Math.max(0.1, 0.1);
      updateZoom();
    }
  });

  function updateZoom() {
    document.querySelectorAll(".image-grid img").forEach(img => {
      img.style.width = `${parseInt(img.style.width) * zoomLevel}px`;
      img.style.height = `${parseInt(img.style.height) * zoomLevel}px`;
    });
  }

  //const splitter = document.getElementById("splitter");

  //splitter.addEventListener("mousedown", (e) => {
  //  e.preventDefault();
  //  document.addEventListener("mousemove", resizePanes);
  //  document.addEventListener("mouseup", () => {
  //    document.removeEventListener("mousemove", resizePanes);
  //  });
  //});

 //function resizePanes(e) {
 //  const leftPane = document.querySelector(".images-panel");
 //  const rightPane = document.querySelector(".drawing-panel");
 //  const totalWidth = leftPane.offsetWidth + rightPane.offsetWidth;
 //  const leftWidth = e.clientX / totalWidth * 100;
 //  leftPane.style.flex = `0 0 ${leftWidth}%`;
 //  rightPane.style.flex = `0 0 ${100 - leftWidth}%`;
 //}

  //const splitterHorizontal = document.getElementById("splitterHorizontal");
 //splitterHorizontal.addEventListener("mousedown", (e) => {
 //  e.preventDefault();
 //  document.addEventListener("mousemove", resizeHorizontalPanes);
 //  document.addEventListener("mouseup", () => {
 //    document.removeEventListener("mousemove", resizeHorizontalPanes);
 //  });
 //});

  function resizeHorizontalPanes(e) {
    const topPane = document.querySelector(".image-grid-panel");
    const bottomPane = document.querySelector(".patterns-grid-panel");
    const totalHeight = topPane.offsetHeight + bottomPane.offsetHeight;
    const topHeight = e.clientY / totalHeight * 100;
    topPane.style.flex = `0 0 ${topHeight}%`;
    bottomPane.style.flex = `0 0 ${100 - topHeight}%`;
  }

  const exportLanguageSelect = document.getElementById("exportLanguageSelect");

  exportLanguageSelect.addEventListener("change", () => {
    const selectedValue = exportLanguageSelect.value;
    const settingExportType = dataStore.find(r => r.Type === "SETTING_EXPORT_TYPE");

    if (settingExportType) {
      settingExportType.Values = selectedValue;
    } else {
      dataStore.push({ Type: "SETTING_EXPORT_TYPE", Values: selectedValue });
    }

    saveDataStore();
  });

  const settingExportType = dataStore.find(r => r.Type === "SETTING_EXPORT_TYPE");

  if (settingExportType) {
    exportLanguageSelect.value = settingExportType.Values;
  } else {
    dataStore.push({ Type: "SETTING_EXPORT_TYPE", Values: "C (MSXgl)" });
    exportLanguageSelect.value = "C (MSXgl)";
  }

  document.getElementById("codeGeneratorButton").addEventListener("click", () => {
    document.getElementById("codeGeneratorModal").style.display = "flex";
    populatePaletteOptions();

    updateScreenModes();
  });



  document.getElementById("targetSelect").addEventListener("change", updateScreenModes);

  function updateScreenModes() {
    const target = document.getElementById("targetSelect").value;
    const screenModeSelect = document.getElementById("screenModeSelect");
    screenModeSelect.innerHTML = "";

    let screenModes = [];
    switch (target) {
      case "MSX":
        screenModes = ["Screen 0", "Screen 1", "Screen 2", "Screen 3"];
        break;
      case "MSX2":
        screenModes = ["Screen 4", "Screen 5", "Screen 6", "Screen 7", "Screen 8"];
        break;
      case "MSX2+":
        screenModes = ["Screen 10", "Screen 11", "Screen 12"];
        break;
      case "MSX Turbo-R":
        screenModes = ["Screen 10", "Screen 11", "Screen 12"];
        break;
      case "V9990":
        screenModes = ["P1", "P2", "B1", "B2", "B3", "B4"];
        break;
    }

    screenModes.forEach(mode => {
      const option = document.createElement("option");
      option.value = mode;
      option.textContent = mode;
      screenModeSelect.appendChild(option);
    });

    updateFilteredGrid();
  }

  

  const paletteSelect = document.getElementById("paletteSelect");
  const ditheringSelect = document.getElementById("dithering");

  paletteSelect.addEventListener("change", () => {
    if (paletteSelect.value !== "areaonlycolors" && paletteSelect.value !== "allimagecolors") {
      ditheringSelect.value = "none";
      ditheringSelect.disabled = true;
    } else {
      ditheringSelect.disabled = false;
    }
  });

  // Trigger change event on page load to set initial state
  paletteSelect.dispatchEvent(new Event("change"));

});

window.addEventListener("unload", () => {
  vscode.postMessage({
    command: 'dispose'
  });
});

/* ======================================================================================
   OPEN DETAILS VIEW
   ====================================================================================== */
let zoomLevel = 1;
let focusedImage = null;
let backgroundColor = "#ffffff";
let patternsBackgroundColor = "#ffffff";

function openDetailsView(record) {
  let command='openDetailsView';
  const childRecord = dataStore.find(r => r.Type === record.ChildObjectType && r.ID.toString() === record.ChildObjectID.toString());
  let spriteTilePaletteRecord=[];
  if(record.Type==="Animations" || record.Type==="Maps"){
    spriteTilePaletteRecord=dataStore.find(r => r.Type === childRecord.ChildObjectType && r.ID.toString() === childRecord.ChildObjectID.toString());
    if(childRecord.Values===null || childRecord.Values===undefined || childRecord.Values.length===0){
      openInfoDialog("No items in \"" + childRecord.Description + "\" " + childRecord.Type.toLowerCase() + " sets", null);
      return;
    }
    command=record.Type=="Animations"?"openAnimationsDetailsView":"openMapsDetailsView";
  }
  vscode.postMessage({
    command: command,
    record: record,
    childRecord: childRecord,
    spriteTilePaletteRecord: spriteTilePaletteRecord,
    dataStore: dataStore
  });
}

function closeDetailsView() {
  document.getElementById("mainPanel").classList.add("active");
  document.getElementById("detailsPanel").classList.remove("active");
}


// ==========
// Free Image
// ==========
function parseData(input) {
  // Suddividi in righe rimuovendo eventuali spazi iniziali/finali
  const lines = input.trim().split("\n").map(line => line.trim());

  const items = [];
  let currentItem = null;
  let palette = [];

  // Flag per capire se siamo arrivati alla sezione PALETTE
  let inPalette = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Se la riga è vuota, ignora e continua
    if (!line) continue;

    // Controlla se è la riga "ITEM"
    if (line.toUpperCase() === "ITEM") {
      // Se c'era un item in costruzione, lo aggiungiamo all'array items
      if (currentItem) {
        items.push(currentItem);
      }
      // Creiamo un nuovo item
      currentItem = [];
      inPalette = false;
      continue;
    }

    // Controlla se è la riga "PALETTE"
    if (line.toUpperCase() === "PALETTE") {
      // Chiudi l'ultimo item, se ce n'era uno in corso
      if (currentItem) {
        items.push(currentItem);
        currentItem = null;
      }
      // Da qui in poi siamo nella sezione PALETTE
      inPalette = true;
      continue;
    }

    // Se siamo dentro la sezione PALETTE,
    // presumibilmente la palette è su un'unica riga
    if (inPalette) {
      // Rimuovi eventuali ";" finali in eccesso, poi splitta
      const values = line
        .replace(/;$/, "") // rimuove un ";" finale se presente
        .split(";")
        .map(v => v.trim())
        .filter(v => v)           // rimuove eventuali stringhe vuote
        .map(v => v.replace(/^0x/i, "")); // rimuove il prefisso "0x" (case insensitive)

      palette = palette.concat(values);
      // Se la palette è davvero su una sola riga, possiamo interrompere qui
      break; 
    } else {
      // Siamo dentro un ITEM, quindi parsiamo la riga come elenco di valori
      const rowValues = line
        .replace(/;$/, "") // rimuove ";" finale se presente
        .split(";")
        .map(v => v.trim())
        .filter(v => v)           // rimuove eventuali stringhe vuote (se ci fosse un separatore in più)
        .map(v => v.replace(/^0x/i, "")); // rimuove "0x" davanti a ogni valore

      currentItem.push(rowValues);
    }
  }

  // Se alla fine abbiamo ancora un item in costruzione, lo aggiungiamo
  if (currentItem) {
    items.push(currentItem);
  }

  return { items, palette };
}



// ------------------
// Esempio di utilizzo
// ------------------
const palette = [
  "0xFF","0x03", // R=F (15 dec) => 15*17=255, B=F =>255, G=3 =>3*17=51 => color #FF33FF (o #FF33FF? attenti a R=F, B=F => #?)
  "0x00","0x0A", // ...
  "0xA2","0x7F",
  // e così via...
];


function getDominantColorsFromDataUrl(base64Image, distancy,croppedImage,transparentColors,itemSize,croppedImageSize,wholeImageSize,paletteOffset,ditherMethod,colorsCount) {
    
    
  paletteOffset=0;
    //const colorThief = new ColorThief();
    const img = new Image();
   
    img.onload = () => {
      const [imageWidth, imageHeight] = wholeImageSize;
        //var palette = colorThief.getPalette(img, thiefMaxColors, 0); 
      const dataUrl = img.src;                              // "data:image/png;base64,iVBORw0K..."
      const base64String = dataUrl.split("base64,")[1]; 
      console.log("COUNT",colorsCount);
      const imageData=getPngDataArray(base64String,"table",imageWidth,imageHeight,1,1,"custom",0,0,0,0,4,"import",true,0,false,0,null,colorsCount,paletteOffset,false,false,"bmp",ditherMethod,"hexa0x","","none",null,0,0,0,0,false,false,true);
      if(imageData[0].toString()=="-1"){
          openValidationDialog(imageData[1]);
          return;
      }
     
      var palette=parseData(imageData[2]);
      //console.log("PALETTE1",palette.palette);
      const hexPalette =[];
      if(colorsCount==15){
            // oppure [...arr];
        hexPalette.push("#000000");
        
        
      }
      for (let i = 0; i < palette.palette.length; i++) {
          hexPalette.push(palette.palette[i]);
      }
      //console.log("PALETTE2",hexPalette);
      
      //return;
      //palette = filterSimilarColors(palette, distancy);
      //const hexPalette = palette.map(color => {
      //    return ('#' + ((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1)).toUpperCase();
      //});
   
      importItemsFromImage(hexPalette,croppedImage,transparentColors,itemSize,croppedImageSize);
    };


 
    var quality = 10;
    img.src = base64Image; 
};

function colorDistance(color1, color2) {
    const rDiff = color1[0] - color2[0];
    const gDiff = color1[1] - color2[1];
    const bDiff = color1[2] - color2[2];
    return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
}


function filterSimilarColors(colors, minDistance = 50) {
    const filteredColors = [];

    colors.forEach(color => {
        let isSimilar = false;

        for (const filteredColor of filteredColors) {
            if (colorDistance(color, filteredColor) < minDistance) {
                isSimilar = true;
                break;
            }
        }

        if (!isSimilar) {
            filteredColors.push(color);
        }
    });

    return filteredColors;
}
function updateCroppedImageDescription(id, newDescription) {
  const image = croppedImages.find(img => img.id === id);
  if (image) {
    image.description = newDescription;
  }
}
function highlightRow(row) {
  document.querySelectorAll(".imported-item-row").forEach(r => {
    r.style.border = "none";
  });
  row.style.border = "3px solid red";
}

function importItemsFromImage(hexPalette, croppedImage, transparentColors, size,croppedImageSize) {
  importPaletteID = -1; // Reset importPaletteID
  //importHexPalette = hexPalette; // Save the palette to the global variable
  const [itemWidth, itemHeight] = size;
  const [imageWidth, imageHeight] = croppedImageSize;
  const objectColumns = parseInt(document.getElementById("objectColumns").value, 10);
  const objectRows = parseInt(document.getElementById("objectRows").value, 10);
  const gapX = parseInt(document.getElementById("gapX").value, 10);
  const gapY = parseInt(document.getElementById("gapY").value, 10);
  const posX = parseInt(document.getElementById("posX").value, 10);
  const posY = parseInt(document.getElementById("posY").value, 10);
 
  const dataUrl = croppedImage;                              // "data:image/png;base64,iVBORw0K..."
  const base64String = dataUrl.split("base64,")[1]; 

  let palettes=[];
  for(let i=0;i<16;i++){
    palettes.push(parseInt(hexPalette[i].substring(1),16));
  }

  const freeImageData=getPngDataArray(base64String,"table",imageWidth,imageHeight,1,1,"input",0,0,0,0,4,"import",false,0,false,0,palettes,16,0,false,false,"bmp","none","hexa0x","","none",null,0,0,0,0,false,false,true);


  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const img = new Image();
  
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Create an array to store all pixels that have transparency
    const transparentPixels = [];

    for (let i = 0; i < data.length; i += 4) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0) {
        data[i] = 1;
        data[i + 1] = 1;
        data[i + 2] = 1;
      }
      if (data[i + 3] < 255) {
        transparentPixels.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // 2. Ensure #000000 is the first element of hexPalette if it exists, otherwise add it
    hexPalette = hexPalette.filter(color => color !== "#000000");
    hexPalette.unshift("#000000");
    if (!hexPalette.includes("#000000")) {
      hexPalette.unshift("#000000");
    }

    // 3. Ensure hexPalette has at least 16 elements
    while (hexPalette.length < 16) {
      hexPalette.push("#FFFFFF");
    }

    // Check if a palette from records is selected
    const selectedPaletteID = document.getElementById("paletteSelect").value;
    if (selectedPaletteID !== "areaonlycolors" && selectedPaletteID !== "allimagecolors") {
   
      const selectedPalette = dataStore.find(p => p.Type === "Palettes" && p.ID.toString() === selectedPaletteID);
      if (selectedPalette) {
        hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
        importPaletteID = selectedPalette.ID;
      }
    }
    //else{
    //  const selectedPalette = dataStore.find(p => p.Type === "Palettes");
    //  hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
    //  console.log("hexPalette",hexPalette);
    //}
    // 5. Replace pixels in croppedImage with colors in transparentColors to fully transparent
    //for (let i = 0; i < data.length; i += 4) {
    //  const pixelColor = `#${((1 << 24) + (data[i] << 16) + (data[i + 1] << 8) + data[i + 2]).toString(16).slice(1).toUpperCase()}`;
    //  if (transparentColors.includes(pixelColor)) {
    //    data[i + 3] = 0; // Set alpha channel to 0 (fully transparent)
    //    if (!transparentPixels.includes([data[i], data[i + 1], data[i + 2], data[i + 3]])) {
    //      transparentPixels.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);
    //    }
    //  }
    //}
    //ctx.putImageData(imageData, 0, 0);
    importPalette=hexPalette;
    // 6. Generate a new base64 image from croppedImage using the closest color in hexPalette
    for (let i = 0; i < data.length; i += 4) {
      const pixelColor = [data[i], data[i + 1], data[i + 2]];
      const closestColor = getClosestColor(pixelColor, hexPalette);
      const [r, g, b] = closestColor;
      data[i] = r;
      data[i + 1] = g;
      data[i + 2] = b;
    }
    ctx.putImageData(imageData, 0, 0);
    const newBase64Image = canvas.toDataURL();
  

    // Create cropped images and fill the importedItemsPanel
    const importedItemsPanel = document.getElementById("importedItemsPanel");
    importedItemsPanel.innerHTML = ""; // Clear previous content
    importPreviewImages = []; // Clear previous cropped images

    // Create a table to hold the color squares and the grid
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.height = "300px";

    // Create the first row for color squares
    const colorRow = document.createElement("tr");
    const colorCell = document.createElement("td");
    colorCell.style.height = "auto";
    const colorSquaresContainer = document.createElement("div");
    colorSquaresContainer.className = "color-squares-container";
    colorSquaresContainer.style.textAlign = "center";
    hexPalette.forEach((color, index) => {
      const colorSquare = document.createElement("span");
      colorSquare.className = "color-square";
      colorSquare.style.backgroundColor = color;
      colorSquare.title = `RGB: ${color}\nMSX: ${rgbToMsx(color)}`;
      if (index === 0) {
        colorSquare.classList.add("checkerboard");
        colorSquare.style.cursor = "default";
      } else {
        colorSquare.addEventListener("dblclick", () => {
          if (index > 0 && !transparentColors.includes(color) && transparentColors.length < 16) {
            const emptyInput = document.querySelector('.transparent-colors input[value=""]');
            if (emptyInput) {
              emptyInput.value = color;
            }
          }
        });
      }

      const labelSpan = document.createElement("span");
      labelSpan.textContent = index.toString(16).toUpperCase();
      const isDark = computeBrightness(color) < 128;
      labelSpan.style.color = isDark ? "#fff" : "#000";
      if (index === 0) {
        labelSpan.style.color = "#444";
      }
      colorSquare.appendChild(labelSpan);
      colorSquaresContainer.appendChild(colorSquare);
    });
    colorCell.style.height = "30px";
    colorCell.appendChild(colorSquaresContainer);
    colorRow.appendChild(colorCell);
    table.appendChild(colorRow);

    // Create the second row for the grid
    const gridRow = document.createElement("tr");
    const gridCell = document.createElement("td");
    gridCell.style.height = "100%";
    gridCell.style.overflowY = "auto"; // Enable vertical scrolling
    gridCell.style.display = "block"; // Ensure the cell takes the full height

    let nextId = getNextIDForType(document.getElementById("typeSelect").value);

    for (let row = 0; row < objectRows; row++) {
      for (let col = 0; col < objectColumns; col++) {
        const x = col * (itemWidth + gapX);
        const y = row * (itemHeight + gapY);
        const itemCanvas = document.createElement("canvas");
        itemCanvas.width = itemWidth;
        itemCanvas.height = itemHeight;
        const itemCtx = itemCanvas.getContext("2d");
        itemCtx.drawImage(canvas, x, y, itemWidth, itemHeight, 0, 0, itemWidth, itemHeight);
        const itemBase64 = itemCanvas.toDataURL();
        // Ensure images for "Tiles" with subtype "Standard" or "Fonts" do not have more than two colors
        if (document.getElementById("typeSelect").value === "Fonts" || (document.getElementById("typeSelect").value === "Tiles" && document.getElementById("subtypeSelect").value === "Standard")) { 
          const uniqueColors = new Set();
          const itemData = itemCtx.getImageData(0, 0, itemWidth, itemHeight).data;
          for (let i = 0; i < itemData.length; i += 4) {
            const color = `rgb(${itemData[i]}, ${itemData[i + 1]}, ${itemData[i + 2]})`;
            uniqueColors.add(color);
            if (uniqueColors.size > 2) {
              openValidationDialog("Images for Tiles (Standard) or Fonts cannot have more than two colors.");
              return;
            }
          }
        }

        // Store the cropped image in the global array
        importPreviewImages.push({
          id: nextId,
          base64: itemBase64,
          description: `${document.getElementById("typeSelect").value.slice(0, -1)} #${nextId}`
        });

        const itemRow = document.createElement("div");
        itemRow.className = "imported-item-row";
        itemRow.style.display = "flex"; // Ensure all elements stay on the same row
        itemRow.style.alignItems = "center"; // Vertically center the elements
        itemRow.style.cursor = "pointer"; // Make the entire row clickable
        itemRow.addEventListener("click", () => {
          const previewImage = document.getElementById("previewImage");
          previewImage.src = itemBase64;
          highlightRow(itemRow);
        });

        const idCell = document.createElement("div");
        idCell.className = "imported-item-cell";
        idCell.style.fontWeight = "bold"; // Make ID bold
        idCell.style.width = "25px"; // Set ID width to 25px
        idCell.textContent = nextId++;

        const imageCell = document.createElement("div");
        imageCell.className = "imported-item-cell";
        const imgElement = document.createElement("img");
        imgElement.src = itemBase64;
        imgElement.style.width = "30px"; // Set image width to 30px
        imgElement.style.height = "30px"; // Set image height to 30px
        imgElement.style.imageRendering = "pixelated"; // Ensure the image is pixelated
        imageCell.appendChild(imgElement);

        const nameCell = document.createElement("div");
        nameCell.className = "imported-item-cell";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.maxLength = 255;
        nameInput.value = `${document.getElementById("typeSelect").value.slice(0, -1)} #${idCell.textContent}`;
        nameInput.title = nameInput.value; // Set initial tooltip
        nameInput.addEventListener("input", (e) => {
          nameInput.title = e.target.value; // Update tooltip on input change
          updateCroppedImageDescription(idCell.textContent, e.target.value);
        });
        nameCell.appendChild(nameInput);

        const removeCell = document.createElement("div");
        removeCell.className = "imported-item-cell";
        const removeButton = document.createElement("button");
        removeButton.textContent = "X";
        removeButton.title = "Remove";
        removeButton.addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent row click event
          removePreviewRow(itemRow, idCell.textContent);
        });
        removeCell.appendChild(removeButton);

        itemRow.appendChild(idCell);
        itemRow.appendChild(imageCell);
        itemRow.appendChild(nameCell);
        itemRow.appendChild(removeCell);

        gridCell.appendChild(itemRow);
      }
    }
    gridRow.style.height = "220px";
    gridRow.appendChild(gridCell);
    table.appendChild(gridRow);

    // Create the third row for the image preview
    const previewRow = document.createElement("tr");
    const previewCell = document.createElement("td");
    previewCell.style.height = "100%";
    previewCell.style.overflow = "auto"; // Enable scrolling
    previewCell.style.display = "block"; // Ensure the cell takes the full height

    const previewContainer = document.createElement("div");
    previewContainer.className = "preview-container";
    const previewSubContainer = document.createElement("div");
    previewSubContainer.className = "preview-subcontainer";


    const previewImage = document.createElement("img");
    previewImage.id = "previewImage";
    previewImage.className = "preview-image";
    previewImage.style.width = "100%"; // Ensure the image fits the container
    previewImage.style.height = "130px";
    previewImage.style.backgroundColor = "#ffffff"; // Default background color
    previewImage.style.cursor = "grab"; // Change cursor to indicate draggable
    previewImage.style.imageRendering = "pixelated"; // Ensure the image is pixelated
    //previewImage.addEventListener("wheel", (e) => {
    //  if (e.ctrlKey) {
    //    e.preventDefault();
    //    let scale = parseFloat(previewImage.style.transform.replace("scale(", "").replace(")", "")) || 1;
    //    scale += e.deltaY < 0 ? 0.1 : -0.1;
    //    scale = Math.max(0.1, scale);
    //    if(scale>1.1){
    //      scale=1.1;
    //    }
    //    previewImage.style.transform = `scale(${scale})`;
    //  }
    //});

    //let isDragging = false;
    //let startX, startY, scrollLeft, scrollTop;

   //previewImage.addEventListener("mousedown", (e) => {
   //  isDragging = true;
   //  startX = e.pageX - previewCell.offsetLeft;
   //  startY = e.pageY - previewCell.offsetTop;
   //  scrollLeft = previewCell.scrollLeft;
   //  scrollTop = previewCell.scrollTop;
   //  previewImage.style.cursor = "grabbing";
   //});

   //previewImage.addEventListener("mouseleave", () => {
   //  isDragging = false;
   //  previewImage.style.cursor = "grab";
   //});

   //previewImage.addEventListener("mouseup", () => {
   //  isDragging = false;
   //  previewImage.style.cursor = "grab";
   //});

   //previewImage.addEventListener("mousemove", (e) => {
   //  if (!isDragging) return;
   //  e.preventDefault();
   //  const x = e.pageX - previewCell.offsetLeft;
   //  const y = e.pageY - previewCell.offsetTop;
   //  const walkX = (x - startX) * 1; // Adjust the multiplier for faster/slower scrolling
   //  const walkY = (y - startY) * 1; // Adjust the multiplier for faster/slower scrolling
   //  previewCell.scrollLeft = scrollLeft - walkX;
   //  previewCell.scrollTop = scrollTop - walkY;
   //});

    const backgroundColorButton = document.createElement("button");
    backgroundColorButton.className = "background-color-button";
    backgroundColorButton.style.width = "100%";
    backgroundColorButton.textContent = "Background color";
    backgroundColorButton.addEventListener("click", () => {
      
      openColorPickerDialog(previewImage.style.backgroundColor, (newColor) => {
        previewImage.style.backgroundColor = newColor;
      });
    });

    previewSubContainer.appendChild(previewImage);
    previewContainer.appendChild(previewSubContainer);
    previewContainer.appendChild(backgroundColorButton);
    previewCell.style.height = "200px";
    previewCell.style.paddingTop = "25px";
    previewCell.appendChild(previewContainer);
    previewRow.appendChild(previewCell);
    table.appendChild(previewRow);

    importedItemsPanel.appendChild(table);

    // Show the import button
    document.getElementById("importImport").style.display = "inline-block";

    // Focus on the first row and display its image in the preview
    const firstRow = document.querySelector(".imported-item-row");
    if (firstRow) {
      highlightRow(firstRow);
      const firstImage = firstRow.querySelector("img");
      if (firstImage) {
        previewImage.src = firstImage.src;
      }
    }
  };
  
  img.src = parseImageData(freeImageData[2]);
}

function removePreviewRow(row, id) {
  const index = importPreviewImages.findIndex(img => img.id === id);
  if (index !== -1) {
    importPreviewImages.splice(index, 1);
    row.remove();
    const rows = document.querySelectorAll(".imported-item-row");
    if (rows.length > 0) {
      const newFocusRow = rows[Math.max(0, index - 1)];
      highlightRow(newFocusRow);
    } else {
      // Hide the import button if no rows are left
      document.getElementById("importImport").style.display = "none";
    }
  }
}

function getClosestColor(pixelColor, hexPalette) {
  let minDistance = Infinity;
  let closestColor = [255, 255, 255];
  hexPalette.forEach(hex => {
    const color = hexToRgb(hex);
    const distance = colorDistance(pixelColor, color);
    if (distance < minDistance) {
      minDistance = distance;
      closestColor = color;
    }
  });

  return closestColor;
}

//function hexToRgb(hex) {
//  const bigint = parseInt(hex.slice(1), 16);
//  const r = (bigint >> 16) & 255;
//  const g = (bigint >> 8) & 255;
//  const b = bigint & 255;
//  return [r, g, b];
//}

function colorDistance(color1, color2) {
  const rDiff = color1[0] - color2[0];
  const gDiff = color1[1] - color2[1];
  const bDiff = color1[2] - color2[2];
  return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
}

/* ======================================================================================
   getRequiredFieldsForType
   ====================================================================================== */
function getRequiredFieldsForType(type) {
  switch (type) {
    case "Sprites":
      return ["Description", "Size", "ChildObjectID", "TagName"]; // Added TagName
    case "Tiles":
      return ["Description", "Size", "ChildObjectID", "TagName"]; // Added TagName
    case "Maps":
      return ["Description", "Size", "ChildObjectID", "TagName"]; // Added TagName
    case "Fonts":
      return ["Description", "Size", "FontSpaces", "FirstFontChar", "LastFontChar", "ChildObjectID", "TagName"]; // Added TagName
    case "Palettes":
      return ["Description", "Values", "TagName"]; // Added TagName
    case "Images":
      return ["Description", "Size", "ChildObjectID", "TagName"]; // Added TagName
    case "Animations":
      return ["Description", "ChildObjectID", "TagName"]; // Added TagName
    default:
      return [];
  }
}
function getFieldNames(type,fieldName) {
  switch (type) {
    case "Sprites":

        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Tiles":
       switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Maps":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Tile";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Fonts":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "FontSpaces":
                return "Spaces (H/V)";
            case "FirstFontChar":
                return "First char";
            case "LastFontChar":
                return "Last char";
            case "ChildObjectID":
                return "PalettTilee";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Palettes":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Values":
                return "Colors";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Images":
    switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
            case "TagName":
                return "TagName"; // Added TagName
        }
    case "Animations":
    switch(fieldName){
            case "Description":
                return "Description";
            case "ChildObjectID":
                return "Sprite/Tile";
            case "TagName":
                return "TagName"; // Added TagName
        }   
    default:
      return [];
  }
}

function scrollToRecord(record) {
  const rows = document.querySelectorAll("#dataGrid tbody tr");
  rows.forEach(row => {
    const cells = row.querySelectorAll("td");
    if (cells.length > 0 && cells[0].textContent == record.ID) {
      row.scrollIntoView({ behavior: "smooth", block: "center" });
      row.classList.add("highlight");
      setTimeout(() => row.classList.remove("highlight"), 2000);
    }
  });
}

function applyFilters(type, subtype) {
  document.getElementById("typeSelect").value = type;
  updateSubtypeCombo();
  if (subtype) {
    document.getElementById("subtypeSelect").value = subtype;
  }
}

function openImportDialog(record) {
  const overlay = document.getElementById("importDialogOverlay");
  const paletteSelect = document.getElementById("paletteSelect");
  const header = document.getElementById("importDialogHeader");
  header.style.fontSize = "20px";
  header.style.fontWeight = "bold";
  // Clear all fields
  document.getElementById("objectColumns").value = 1;
  document.getElementById("objectRows").value = 1;
  document.getElementById("gapX").value = 0;
  document.getElementById("gapY").value = 0;
  document.getElementById("posX").value = 0;
  document.getElementById("posY").value = 0;
  document.getElementById("minColorsDistance").value = 1;
  document.getElementById("importFile").value = "";
  document.getElementById("selectedImage").src = "";
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";

  // Remove color squares and grid if they exist
  const colorSquaresContainer = document.querySelector(".color-squares-container");
  if (colorSquaresContainer) {
    colorSquaresContainer.remove();
  }
  const importedItemsPanel = document.getElementById("importedItemsPanel");
  importedItemsPanel.innerHTML = "";

  // Set header text
  const recordType = record.Type.slice(0, -1); // Remove last character
  header.innerHTML = `${recordType} set "${record.Description}" (${record.Size})`;
  //header.textContent = `<label style="font-weight: bold;font-size: 20px;">${recordType} ${record.Description}</label>`;
  paletteSelect.innerHTML = '<option value="areaonlycolors">Create a new palette (only selected area colors)</option><option value="allimagecolors">Create a new palette (all image colors)</option>';
  getPaletteOptions().forEach(opt => {
    let option = document.createElement("option");
    option.value = opt.value;
    option.textContent = opt.label;
    paletteSelect.appendChild(option);
  });

  // Check the number of items in the record
  const ditheringSelect = document.getElementById("dithering");
  if (record.Values && record.Values.length > 0) {
    // Set the palette to the record's palette and disable the combo
    paletteSelect.value = record.ChildObjectID;
    paletteSelect.disabled = true;
    ditheringSelect.disabled = true;
  } else {
    // Enable the combo for palette selection
    paletteSelect.disabled = false;
    ditheringSelect.disabled = false;
  }

  overlay.style.display = "flex";
  overlay.dataset.recordId = record.ID; // Store the record ID in the overlay for later use
}

document.getElementById("importFile").addEventListener("change", () => {
  const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }
  const record = dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10));
  const importFile = document.getElementById("importFile").files[0];
  const paletteOption = document.getElementById("paletteSelect").value;

  // Hide import button and clear previous preview
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";
  document.getElementById("selectedImage").src = "";
  const importedItemsPanel = document.getElementById("importedItemsPanel");
  importedItemsPanel.innerHTML = "";

  if (!importFile || (importFile.type !== "image/png" && importFile.type !== "image/bmp")) {
    openValidationDialog("Please select a valid PNG or BMP file.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function(event) {
    const base64Image = event.target.result;
    if (!isValidImage(base64Image)) {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
      return;
    }

    const img = new Image();
    img.onload = function() {
      const imgWidth = img.width;
      const imgHeight = img.height;
      const [recordWidth, recordHeight] = record.Size.split("x").map(Number);
      const totalWidth = (recordWidth * importSpecs.objectColumns) + parseInt(importSpecs.posX, 10);
      const totalHeight = (recordHeight * importSpecs.objectRows) + parseInt(importSpecs.posY, 10);

      if (imgWidth < totalWidth || imgHeight < totalHeight) {
        openValidationDialog("Total width or height set for extracting items is incompatible with the image.");
        document.getElementById("selectedImage").src = "";
        document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
        return;
      }

      // Display the image in the selected-image panel
      const selectedImage = document.getElementById("selectedImage");
      selectedImage.src = base64Image;

      // Proceed with preview
      document.getElementById("importedItemsPanel").style.display = "grid"; // Show the preview panel
      document.getElementById("importPreview").style.display = "inline-block"; // Show the Preview button
      document.getElementById("importImport").style.display = "none"; // Hide the Import button initially
      vscode.postMessage({
        command: 'validateImportSpecs',
        data: importSpecs,
        record: record,
        paletteOption: paletteOption
      });
    };
    img.onerror = function() {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    };
    img.src = base64Image;
  };
  reader.readAsDataURL(importFile);
});

document.getElementById("importPreview").addEventListener("click", () => {
  if (!freeImageModuleIsReady){
    openValidationDialog("FreeImage module is not ready.");
    return;
  }
  const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }
  const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
  const importFile = document.getElementById("importFile").files[0];
  const paletteOption = document.getElementById("paletteSelect").value;
  const minColorsDistance = parseInt(document.getElementById("minColorsDistance").value, 10);

  if (!importFile || (importFile.type !== "image/png" && importFile.type !== "image/bmp")) {
    openValidationDialog("Please select a valid PNG or BMP file.");
    return;
  }

  const objectColumns = parseInt(document.getElementById("objectColumns").value, 10);
  const objectRows = parseInt(document.getElementById("objectRows").value, 10);
  const gapX = parseInt(document.getElementById("gapX").value, 10);
  const gapY = parseInt(document.getElementById("gapY").value, 10);
  const posX = parseInt(document.getElementById("posX").value, 10);
  const posY = parseInt(document.getElementById("posY").value, 10);
  const ditherMethod = document.getElementById("dithering").value;

  // Validate number of columns and rows
  if (objectColumns < 1 || objectRows < 1) {
    openValidationDialog("Impostare il numero di righe e colonne di items da importare");
    document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    return;
  }

  // Validate color distance if creating a new palette
  if ((paletteOption === "areaonlycolors" || paletteOption === "allimagecolors") && (minColorsDistance < 1 || minColorsDistance > 255)) {
    openValidationDialog("Invalid color distance");
    document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    return;
  }

  const [recordWidth, recordHeight] = record.Size.split("x").map(Number);

  const totalWidth =  (recordWidth * objectColumns) + (gapX * (objectColumns - 1));
  const totalHeight =  (recordHeight * objectRows) + (gapY * (objectRows - 1));

  // Set thiefMaxColors based on type and subtype
  if (currentType === "Fonts" || (currentType === "Tiles" && currentSubtype === "Standard")) {
    thiefMaxColors = 2;
  } else {
    thiefMaxColors = 15;
  }

  const reader = new FileReader();
  reader.onload = function(event) {

    const base64Image = event.target.result;
    if (!isValidImage(base64Image)) {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
      return;
    }

    const img = new Image();
    img.onload = function() {
  
      const imgWidth = img.width;
      const imgHeight = img.height;

      // Validate image dimensions
      if (imgWidth < totalWidth || imgHeight < totalHeight) {
        openValidationDialog("Image size incompatible with the specified parameters");
        document.getElementById("selectedImage").src = "";
        document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
        return;
      }

      // Create a canvas to draw the cropped image
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = totalWidth;
      canvas.height = totalHeight;
      ctx.drawImage(img, posX, posY, totalWidth, totalHeight, 0, 0, totalWidth, totalHeight);
      const croppedImage = canvas.toDataURL();
      //console.log("CANVAS",canvas);
      //console.log("CROPPED IMAGE",croppedImage);
      // Get transparent colors
      const transparentColors = Array.from(document.querySelectorAll('.transparent-colors input'))
        .map(input => input.value.toUpperCase())
        .filter(color => color);

      // Define hexPalette
      let hexPalette = [];

      // If a new palette needs to be created
      if (paletteOption === "areaonlycolors" || paletteOption === "allimagecolors") {
        //console.log("IMAGE TO USE",paletteOption,croppedImage,base64Image);
        
        const imageToUse = paletteOption === "areaonlycolors" ? croppedImage : img.src;
        croppedImportImages=croppedImage;
        noCroppedImportImages=imageToUse;

        processImageForTransparency(croppedImportImages, (processedImage,imageHasTransparentColors) => {
          croppedImportImages=processedImage;
          croppedImageColorCounter=imageHasTransparentColors?16:15;
          processImageForTransparency(noCroppedImportImages, (processedImage,imageHasTransparentColors) => {
            noCroppedImportImages=processedImage;
            noCroppedImageColorCounter=imageHasTransparentColors?16:15;
            getDominantColorsFromDataUrl(noCroppedImportImages, minColorsDistance, croppedImportImages, transparentColors, [recordWidth, recordHeight], [totalWidth, totalHeight], [imgWidth, imgHeight],minColorsDistance,ditherMethod, noCroppedImageColorCounter);
        });
      });









        
        //getDominantColorsFromDataUrl(imageToUse, minColorsDistance, croppedImage, transparentColors, [recordWidth, recordHeight]);
      } else {
        const selectedPalette = dataStore.find(p => p.Type === "Palettes" && p.ID.toString() === paletteOption);
        if (selectedPalette) {
          hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
          importItemsFromImage(hexPalette, croppedImage, transparentColors, [recordWidth, recordHeight], [totalWidth, totalHeight]);
        }
      }
     
      // Show the import button after successful preview
      document.getElementById("importImport").style.display = "inline-block";
    };







    img.onerror = function() {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    };
    img.src = base64Image;
  };
  reader.readAsDataURL(importFile);
});

document.getElementById("importClose").addEventListener("click", () => {
  document.getElementById("importDialogOverlay").style.display = "none";
  document.getElementById("selectedImage").src = "";
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";
});





function openValidationDialog(message) {
  const overlay = document.getElementById("validationOverlay");
  const msg = document.getElementById("validationMessage");
  msg.textContent = message;
  overlay.style.display = "flex";
}

document.getElementById("validationOk").addEventListener("click", () => {
  document.getElementById("validationOverlay").style.display = "none";
});

function isValidImage(base64Image) {
  const pngHeader = "data:image/png;base64,";
  const bmpHeader = "data:image/bmp;base64,";
  return base64Image.startsWith(pngHeader) || base64Image.startsWith(bmpHeader);
}

document.querySelectorAll('.tab-button').forEach(button => {
  button.addEventListener('click', () => {
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    button.classList.add('active');
    document.getElementById(button.dataset.tab).classList.add('active');
  });
});



document.querySelectorAll('.transparent-colors input').forEach(input => {
  input.addEventListener('blur', () => {
    if (!/^#[0-9A-F]{6}$/i.test(input.value)) {
      input.value = '';
    }
  });
});

document.getElementById("selectedImagePanel").addEventListener("wheel", (e) => {
  if (e.ctrlKey) {
    e.preventDefault();
    const img = document.getElementById("selectedImage");
    let scale = parseFloat(img.style.transform.replace("scale(", "").replace(")", "")) || 1;
    scale += e.deltaY < 0 ? 0.1 : -0.1;
    scale = Math.max(0.1, scale);
    img.style.transform = `scale(${scale})`;
  }
});

let isDragging = false;
let startX, startY, scrollLeft, scrollTop;

const selectedImagePanel = document.getElementById("selectedImagePanel");
const selectedImage = document.getElementById("selectedImage");

selectedImagePanel.addEventListener("mousedown", (e) => {
  isDragging = true;
  startX = e.pageX - selectedImagePanel.offsetLeft;
  startY = e.pageY - selectedImagePanel.offsetTop;
  scrollLeft = selectedImagePanel.scrollLeft;
  scrollTop = selectedImagePanel.scrollTop;
  selectedImage.style.cursor = "grabbing";
});

selectedImagePanel.addEventListener("mouseleave", () => {
  isDragging = false;
  selectedImage.style.cursor = "grab";
});

selectedImagePanel.addEventListener("mouseup", () => {
  isDragging = false;
  selectedImage.style.cursor = "grab";
});

selectedImagePanel.addEventListener("mousemove", (e) => {
  if (!isDragging) return;
  e.preventDefault();
  const x = e.pageX - selectedImagePanel.offsetLeft;
  const y = e.pageY - selectedImagePanel.offsetTop;
  const walkX = (x - startX) * 1; // Adjust the multiplier for faster/slower scrolling
  const walkY = (y - startY) * 1; // Adjust the multiplier for faster/slower scrolling
  selectedImagePanel.scrollLeft = scrollLeft - walkX;
  selectedImagePanel.scrollTop = scrollTop - walkY;
});

document.getElementById("importImport").addEventListener("click", () => {
  openConfirmDialog(() => {
    const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
    const currentType = document.getElementById("typeSelect").value;
    let currentSubtype = "";
    if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
      currentSubtype = document.getElementById("subtypeSelect").value;
    }
    const record = dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10));
    const type = document.getElementById("typeSelect").value;
    const newItems = [];

    importPreviewImages.forEach((image, index) => {
      const item = {
        ID: index + 1,
        Name: image.description,
        Order: getNextOrder(record.Values),
        Matrices: [{
          ID: 1,
          Values: [],
          OrOptions: Array.from({ length: parseInt(record.Size.split("x")[1], 10) }, (_, rowIndex) => ({
            Row: rowIndex,
            Status: false
          }))
        }]
      };

      const img = new Image();
      img.src = image.base64;
      img.onload = () => {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            const pixelColor = [data[i], data[i + 1], data[i + 2]];
            const colorIndex = importPalette.findIndex(c => {
              const [r, g, b] = hexToRgb(c);
              return r === pixelColor[0] && g === pixelColor[1] && b === pixelColor[2];
            });
           
            item.Matrices[0].Values.push({
              PosX: x,
              PosY: y,
              Value: colorIndex.toString(16).toUpperCase()
            });
          }
        }

        newItems.push(item);

        if (newItems.length === importPreviewImages.length) {
          if (importPaletteID === -1) {
            // Ensure the new palette has 16 colors
            const newPaletteColors = importPalette.map((color, index) => ({
              id: index.toString(16).toUpperCase(),
              color: color
            }));
            newPaletteColors[0] = { id: "0", color: "#000000" };
            while (newPaletteColors.length < 16) {
              newPaletteColors.push({ id: newPaletteColors.length.toString(16).toUpperCase(), color: "#FFFFFF" });
            }

            const newPalette = {
              ID: getNextIDForType("Palettes"),
              Type: "Palettes",
              Description: `Palette for ${type} set "${record.Description}"`,
              Subtype: "",
              Values: newPaletteColors
            };
            dataStore.push(newPalette);
            record.ChildObjectID = newPalette.ID;
          } else {
            record.ChildObjectID = importPaletteID;
          }

          record.Values = newItems;
          saveDataStore();
          document.getElementById("importDialogOverlay").style.display = "none";
          updateGrid();
        }
      };
    });
  });
});

function getNextOrder(values) {
  if (!values || values.length === 0) return 1;
  return Math.max(...values.map(v => v.Order)) + 1;
}

function openConfirmDialog(onConfirm) {
  const overlay = document.getElementById("confirmOverlay");
  const msg = document.getElementById("confirmDialog").querySelector("p");
  const okBtn = document.getElementById("confirmOk");
  const cancelBtn = document.getElementById("confirmCancel");

  msg.textContent = "Are you sure to import these items?";
  overlay.style.display = "flex";
  overlay.style.zIndex = "9999"; // Ensure the z-index is the same as the color picker dialog

  const onOk = () => {
    closeConfirm();
    onConfirm();
  };
  const onCancel = () => {
    closeConfirm();
  };
  const closeConfirm = () => {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);
  };

  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);
}

function exportRecord(record) {
  let cArray='';
  const exportType= dataStore.find(r => r.Type === "SETTING_EXPORT_TYPE").Values;
  switch(record.Type) {
    case "Sprites":
      cArray=exportSprites(record,exportType);
      break;
    case "Tiles":
      cArray=exportTiles(record,exportType);
          break;
    case "Maps":
      cArray=exportMaps(record,exportType);
      break;
    case "Fonts":
      cArray=exportFonts(record,exportType);
      break;
    case "Palettes":
      cArray=exportPalette(record,exportType);
      break;
    case "Images":
      cArray=exportImages(record,exportType);
      break;
    default:
      break;
  }
 
  openExportDialogPanel(cArray,record);
}

function openExportDialogPanel(text,record) {
  const overlay = document.getElementById("exportDialogOverlay");
  const header = document.getElementById("exportDialogHeader");
  const recordType = record.Type.slice(0, -1); // Remove last character
  header.innerHTML = `${recordType} set "${record.Description}"`;
  header.style.fontSize = "20px";
  header.style.fontWeight = "bold";

  const exportText = document.getElementById("exportText");



  exportText.value = text;

  overlay.style.display = "flex";
}

document.getElementById("exportClose").addEventListener("click", () => {
  document.getElementById("exportDialogOverlay").style.display = "none";
});

document.getElementById("zoomIn").addEventListener("click", () => {
  const exportText = document.getElementById("exportText");
  let currentSize = parseInt(window.getComputedStyle(exportText).fontSize);
  if (currentSize < 30) {
    exportText.style.fontSize = `${currentSize + 1}px`;
  }
});

document.getElementById("zoomOut").addEventListener("click", () => {
  const exportText = document.getElementById("exportText");
  let currentSize = parseInt(window.getComputedStyle(exportText).fontSize);
  if (currentSize > 15) {
    exportText.style.fontSize = `${currentSize - 1}px`;
  }
});

document.getElementById("exportText").addEventListener("wheel", (e) => {
  if (e.ctrlKey) {
    e.preventDefault();
    const exportText = document.getElementById("exportText");
    let currentSize = parseInt(window.getComputedStyle(exportText).fontSize);
    if (e.deltaY < 0 && currentSize < 25) {
      exportText.style.fontSize = `${currentSize + 1}px`;
    } else if (e.deltaY > 0 && currentSize > 15) {
      exportText.style.fontSize = `${currentSize - 1}px`;
    }
  }
});

document.addEventListener("DOMContentLoaded", () => {
  populatePaletteOptions();
  updateScreenModes();
  updateFilteredGrid();

  document.getElementById("codePaletteSelect").addEventListener("change", updateFilteredGrid);
  document.getElementById("targetSelect").addEventListener("change", updateScreenModes);
  document.getElementById("screenModeSelect").addEventListener("change", updateFilteredGrid);
});
function populatePaletteOptions() {
    const paletteSelect = document.getElementById("paletteSelect");
    paletteSelect.innerHTML = ""; // Clear existing options
    const palettes = dataStore.filter(r => r.Type === "Palettes");
    palettes.forEach(palette => {
      const option = document.createElement("option");
      option.value = palette.ID;
      option.textContent = palette.Description;
      paletteSelect.appendChild(option);
    });

    const codePaletteSelect = document.getElementById("codePaletteSelect"); // Added this line
    codePaletteSelect.innerHTML = ""; // Clear existing options
    palettes.forEach(palette => {
      const option = document.createElement("option");
      option.value = palette.ID;
      option.textContent = palette.Description;
      codePaletteSelect.appendChild(option);
    });
  }

//function populatePaletteOptions() {
//  const paletteSelect = document.getElementById("paletteSelect");
//  const palettes = dataStore.filter(r => r.Type === "Palettes");
//  palettes.forEach(palette => {
//    const option = document.createElement("option");
//    option.value = palette.ID;
//    option.textContent = palette.Description;
//    paletteSelect.appendChild(option);
//  });
//}

function updateFilteredGrid() {
  const paletteSelect = document.getElementById("codePaletteSelect").value;
  const screenModeSelect = document.getElementById("screenModeSelect").value;
  const screenModeValue = screenModeSelect.replace(/\D/g, ''); // Extract numeric part
  const tbody = document.getElementById("filteredGrid").querySelector("tbody");
  tbody.innerHTML = "";

  const filteredData = dataStore.filter(record => {
    const childObjectID = record.ChildObjectID?record.ChildObjectID.toString():"";
    if (record.Type === "Animations") return false;
    if (paletteSelect && childObjectID !== parseInt(paletteSelect, 10).toString()) {
      return false;
    };
    if (screenModeValue) {
      if (record.Type === "Sprites" && ["0"].includes(screenModeValue)){
        return false;
      }
      if (["Sprites"].includes(record.Type) && ["0", "1", "2", "3"].includes(screenModeValue)) {
        if (record.Subtype === "Type 2"){
          return false;
        } 
      }
      if (record.Type === "Tiles" && record.Subtype === "Bitmap" && ["0", "1", "2", "3", "4"].includes(screenModeValue)){
        return false;
      }
      if (record.Type === "Images" && !["5", "6", "7", "8", "10", "12"].includes(screenModeValue)){
        return false;
      } 
      if (record.Type === "Fonts") {
        if (!["0", "1", "2", "3", "4", "5", "6", "7", "8","10","12"].includes(screenModeValue)) {
          return false;
        }
      }
    }
    return true;
  });
  codGeneratorMachine=document.getElementById("targetSelect").value;
  codeGeneratorScreenMode=screenModeValue;
  codeGeneratorItems=[];
  codeGeneratorItems.push(dataStore.filter(r => r.Type === "Palettes" && r.ID.toString()===parseInt(paletteSelect, 10).toString())[0]);

  filteredData.forEach(record => {
    codeGeneratorItems.push(record); // Add record to debug array

    const tr = document.createElement("tr");
    const tdSelect = document.createElement("td");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = true; // Check the checkbox by default
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        if (record.Type === "Fonts") {
          const comboBox = document.querySelector(`#comboBox_${record.ID}`);
          if (comboBox) {
            record.exportType = comboBox.value;
          }
        }
        codeGeneratorItems.push(record);
      } else {
        codeGeneratorItems = codeGeneratorItems.filter(r => r.ID !== record.ID);
      }
    });
    tdSelect.appendChild(checkbox);
    tr.appendChild(tdSelect);

    const tdID = document.createElement("td");
    tdID.textContent = record.ID;
    tr.appendChild(tdID);

    const tdDescription = document.createElement("td");
    tdDescription.textContent = record.Description;
    tr.appendChild(tdDescription);

    const tdType = document.createElement("td");
    tdType.textContent = record.Type;
    tr.appendChild(tdType);

    const tdSubtype = document.createElement("td");
    tdSubtype.textContent = record.Subtype;
    tr.appendChild(tdSubtype);

    const tdFontMode = document.createElement("td");
    if (record.Type === "Fonts") {
      const fontModeSelect = document.createElement("select");
      fontModeSelect.id = `comboBox_${record.ID}`;
      const fontModes = getFontModesForScreen(screenModeValue);
      fontModes.forEach(mode => {
        const option = document.createElement("option");
        option.value = mode;
        option.textContent = mode;
        fontModeSelect.appendChild(option);
      });
      tdFontMode.appendChild(fontModeSelect);
    }
    tr.appendChild(tdFontMode);

    tbody.appendChild(tr);
  });

 
}

function updateScreenModes() {
  const target = document.getElementById("targetSelect").value;
  const screenModeSelect = document.getElementById("screenModeSelect");
  screenModeSelect.innerHTML = "";

  let screenModes = [];
  switch (target) {
    case "MSX":
      screenModes = ["Screen 0", "Screen 1", "Screen 2", "Screen 3"];
      break;
    case "MSX2":
      screenModes = ["Screen 4", "Screen 5", "Screen 6", "Screen 7", "Screen 8"];
      break;
    case "MSX2+":
      screenModes = ["Screen 10", "Screen 11", "Screen 12"];
      break;
    case "MSX Turbo-R":
      screenModes = ["Screen 10", "Screen 11", "Screen 12"];
      break;
    case "V9990":
      screenModes = ["P1", "P2", "B1", "B2", "B3", "B4"];
      break;
  }

  screenModes.forEach(mode => {
    const option = document.createElement("option");
    option.value = mode;
    option.textContent = mode;
    screenModeSelect.appendChild(option);
  });

  updateFilteredGrid();
}

function getFontModesForScreen(screenMode) {
  switch (screenMode) {
    case "0":
    return ["Text"];
    case "1":
    case "2":
      return ["Text","Sprites"];
    case "3":
      return ["Sprites"];
    case "4":
      return ["Text","Sprites"];
    case "5":
    case "6":
    case "7":
    case "8":
      return ["Bitmap", "Transparent bitmap", "VRAM","Sprites"];
    case "10":
    case "11":
    case "12":
      return ["Sprites"];
    default:
      return [];
  }
}

document.getElementById("codeGeneratorCancelTop").addEventListener("click", () => {
  document.getElementById("codeGeneratorModal").style.display = "none";
});


document.getElementById("codeGeneratorWrite").addEventListener("click", () => {
  document.getElementById("codeGeneratorModal").style.display = "none";

  // Update codeGeneratorItems with the selected export type for Fonts
  codeGeneratorItems.forEach(record => {
    if (record.Type === "Fonts") {
      const comboBox = document.querySelector(`#comboBox_${record.ID}`);
      if (comboBox) {
        record.exportType = comboBox.value;
      }
    }
  });

  openCodeGeneratorDialog();
});

function openCodeGeneratorDialog() {
  const overlay = document.getElementById("exportDialogOverlay");
  const header = document.getElementById("exportDialogHeader");
  const exportText = document.getElementById("exportText");

  header.innerHTML = "MSXgl code generator";
  header.style.fontSize = "20px";
  header.style.fontWeight = "bold";


  exportText.value = CreateCode(codeGeneratorItems, codeGeneratorScreenMode, codGeneratorMachine);

  overlay.style.display = "flex";
}

document.getElementById("exportClose").addEventListener("click", () => {
  document.getElementById("exportDialogOverlay").style.display = "none";
});

document.getElementById("exportCopy").addEventListener("click", async () => {
  const exportText = document.getElementById("exportText").value;
  try {
    await navigator.clipboard.writeText(exportText);
    alert("Text copied to clipboard.");
  } catch (err) {
    console.error("Failed to copy text: ", err);
  }
});

function createCombinedImage(record, paletteRecord, show) {


  const images = record.Values.map(value => getImageFromObject(value.ID, record, paletteRecord));
  const [width, height] = record.Size.split('x').map(Number);
  const numImages = images.length;
  const numCols = Math.ceil(Math.sqrt(numImages));
  const numRows = Math.ceil(numImages / numCols);
  const totalWidth = width * numCols;
  const totalHeight = height * numRows;

  const canvas = document.createElement('canvas');
  canvas.width = totalWidth;
  canvas.height = totalHeight;
  const ctx = canvas.getContext('2d');

  return new Promise((resolve, reject) => {
    let loadedImages = 0;

    images.forEach((imageData, index) => {
      const img = new Image();
      img.onload = () => {
        const col = index % numCols;
        const row = Math.floor(index / numCols);
        ctx.drawImage(img, width * col, height * row, width, height);
        loadedImages++;

        if (loadedImages === images.length) {
          if (show) {
            document.getElementById("combinedImage").src = canvas.toDataURL();
            resolve();
          } else {
            resolve(canvas);
          }
        }
      };
      img.onerror = reject;
      img.src = imageData;
    });
  });
}

document.addEventListener("DOMContentLoaded", () => {
  // ...existing code...cas

  document.getElementById("imageDialogClose").addEventListener("click", () => {
    document.getElementById("imageDialogOverlay").style.display = "none";
  });

  document.getElementById("imageDialogCopy").addEventListener("click", async () => {
    const img = document.getElementById("combinedImage");
    try {
      const response = await fetch(img.src);
      const blob = await response.blob();
      const item = new ClipboardItem({ "image/png": blob });
      await navigator.clipboard.write([item]);
      //alert("Image copied to clipboard.");
    } catch (err) {
      console.error("Failed to copy image: ", err);
    }
  });

  const combinedImage = document.getElementById("combinedImage");
  combinedImage.addEventListener("wheel", (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      let scale = parseFloat(combinedImage.style.transform.replace("scale(", "").replace(")", "")) || 1;
      scale += e.deltaY < 0 ? 0.1 : -0.1;
      scale = Math.max(0.1, scale);
      combinedImage.style.transform = `scale(${scale})`;
    }
  });
});

</script>
</body>
</html>
