<!--

/**
 * MSXDev Tool Extension for VS Code
 * Copyright (C) 2025  Fausto Pracek
 *
 * This file is part of MSXDev Tool Extension for VS Code.
 *
 * MSXDev Tool Extension for VS Code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MSXDev Tool Extension for VS Code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MSXDev Tool Extension for VS Code. If not, see <https://www.gnu.org/licenses/>.
 */

-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSX Dev Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    label {
      font-weight: bold;
      margin-right: 5px;
      color: black; /* Change text color to black */
    }
    #filters label {
      color: white; /* Keep filter labels white */
    }
    select, input, button {
      margin: 5px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    thead {
      background-color: #ddd;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
      color: black; /* Change text color to black */
    }
    /* Color squares (for Palettes) */
    .color-square {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      margin: 2px;
      border: 1px solid #999;
      vertical-align: middle;
      box-sizing: border-box;
      cursor: pointer;
      position: relative;
      text-align: center; /* Center text horizontally */
    }
    .color-square span {
      font-size: 12px;
      font-weight: bold;
      display: inline-block;
      width: 100%; /* Ensure the span takes the full width of the square */
      text-align: center; /* Center text horizontally */
    }
    .checkerboard {
      background: repeating-linear-gradient(
        45deg,
        #ccc 0,
        #ccc 5px,
        #fff 5px,
        #fff 10px
      );
      cursor: not-allowed;
    }
    .action-button {
      margin: 2px;
      padding: 3px 5px;
      cursor: pointer;
    }
    .action-button:hover {
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
    .details-view {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .details-buttons {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .imports-buttons {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .main-detail-panel {
      flex: 1;
      display: flex;
    }
    .drawing-panel {
      flex: 1;
      background: #f9f9f9;
      overflow: auto;
    }
    .images-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .splitter {
      background: #ccc;
      width: 5px;
      cursor: col-resize;
    }
    .splitter-horizontal {
      background: #ccc;
      height: 5px;
      cursor: row-resize;
    }
    .image-grid-panel, .patterns-grid-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .image-grid-title, .patterns-grid-title {
      font-weight: bold;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    .color-picker {
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    .image-grid, .patterns-grid {
      flex: 1;
      display: grid;
      gap: 5px;
      padding: 10px;
      overflow: auto;
    }
    .image-grid img, .patterns-grid img {
      border: 2px solid black;
      cursor: pointer;
    }
    .image-grid img.focused, .patterns-grid img.focused {
      border: 2px solid red;
      outline: 2px solid black;
    }
    .image-grid img:not(.focused), .patterns-grid img:not(.focused) {
      border: 1px solid white;
    }
    .panel {
      display: none;
    }
    .panel.active {
      display: block;
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9998; /* Default z-index for overlays */
    }
    .color-picker-overlay {
      z-index: 9999; /* Higher z-index for color picker overlay */
    }
    .dialog {
      background: #fff;
      padding: 20px;
      border: 1px solid #666;
      border-radius: 4px;
      min-width: 250px;
      text-align: center;
      color: black;
    }
    .form-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .form-group label {
      width: 150px; /* Adjust this width based on the longest label */
      color: white; /* Set label font color to white */
      text-align: left; /* Align labels to the left */
      margin-right: 10px;
    }
    .form-group input,
    .form-group select,
    .form-group div {
      flex: 1;
    }
    .form-group input[type="file"] {
      flex: 1;
    }
    .color-picker-dialog {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .color-picker-dialog label,
    .color-picker-dialog input,
    .color-picker-dialog button {
      margin: 0 5px;
    }
    .import-dialog {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Align items to the top left */
      justify-content: flex-start;
      width: 900px; /* Fixed width */
      height: 700px; /* Fixed height */
      position: relative; /* Add relative positioning */
    }
    .import-dialog .header,
    .import-dialog .tabs,
    .import-dialog .form-group {
      align-self: flex-start; /* Align individual elements to the left */
    }
    .import-dialog .form-group {
      justify-content: flex-start; /* Align form group contents to the left */
    }
    .import-dialog .form-group label {
      text-align: left; /* Align labels to the left */
      color: black; /* Set label font color to black */
    }
    .import-dialog .form-group input,
    .import-dialog .form-group select {
      text-align: left; /* Align input and select contents to the left */
    }
    .import-dialog .preview-panel {
      display: block; /* Always visible */
      flex: 1;
      background-color: #f9f9f9;
      height: 100%; /* Adjust height to match all fields */
      width: 100%; /* Adjust width to fill the column */
    }
    .import-dialog .selected-image {
      display: block;
      flex: 1;
      background-color: #f9f9f9;
      height: calc(100% - 300px); /* Adjust height to fill available space */
      width: 100%; /* Adjust width to fill the column */
      border: 1px solid #ccc; /* Add border */
      overflow: hidden; /* Hide overflow to enable dragging */
      position: relative; /* Ensure positioning context for the image */
    }
    .selected-image img {
      image-rendering: pixelated; /* Pixelate the image */
      width: 100%; /* Ensure the image fits the container */
      height: auto;
      transform-origin: center; /* Ensure zooming happens from the center */
      position: absolute; /* Allow the image to be positioned absolutely */
      top: 0;
      left: 0;
      cursor: grab; /* Change cursor to indicate draggable */
    }
    .selected-image img:active {
      cursor: grabbing; /* Change cursor when dragging */
    }
    .import-dialog .selected-image {
      display: block;
      flex: 1;
      background-color: #f9f9f9;
      height: calc(100% - 300px); /* Adjust height to fill available space */
      width: 100%; /* Adjust width to fill the column */
      border: 1px solid #ccc; /* Add border */
      overflow: auto; /* Enable scrolling */
    }
    .import-dialog .form-group-container {
      display: flex;
      width: 100%;
    }
    .import-dialog .form-group-container .form-group {
      flex: 1;
    }
    .import-dialog .header {
      font-weight: bold;
      margin-bottom: 20px;
    }
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    .tab-button {
      padding: 10px 20px;
      cursor: pointer;
      border: none;
      background: #ddd;
      margin: 0 5px;
    }
    .tab-button.active {
      background: #bbb;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .transparent-colors {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .transparent-colors input {
      width: 110px; /* Set width to 100px */
    }
    .form-actions {
      position: absolute; /* Position absolutely */
      bottom: 20px; /* 20px from the bottom */
      right: 20px; /* 20px from the right */
      display: flex;
      justify-content: flex-end; /* Align OK and Cancel buttons to the right */
      width: auto;
    }
    .preview-container {
      position: relative;
      height: 100%;
    }
    .preview-image {
      width: 100%;
      height: auto;
      background-color: #ffffff;
      cursor: grab;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: center;
    }
    .background-color-button {
      position: absolute;
      bottom: 0;
      width: 235px;
      text-align: center;
      background-color: #f0f0f0;
      border-top: 1px solid #ccc;
      padding: 5px 0;
    }
  </style>
</head>
<body>

<div id="mainPanel" class="panel active">
  <!-- FILTERS -->
  <div id="filters">
    <label for="typeSelect">Type:</label>
    <select id="typeSelect">
      <option value="Sprites">Sprites sets</option>
      <option value="Tiles">Tiles sets</option>
      <option value="Maps">Maps sets</option>
      <option value="Fonts">Fonts sets</option>
      <option value="Palettes">Palettes</option>
      <option value="Images">Images sets</option>
      <option value="Animations">Animations sets</option>
    </select>

    <label for="subtypeSelect" id="subtypeLabel" class="hidden">Subtype:</label>
    <select id="subtypeSelect" class="hidden"></select>
  </div>

  <!-- DATA TABLE -->
  <table id="dataGrid">
    <thead>
      <tr id="gridHeader"></tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Add button -->
  <button id="addButton">New</button>

  <!-- Edit dialog -->
  <div id="editDialog" class="hidden"></div>
</div>

  <!-- Overlay: colorPicker -->
  <div id="colorPickerOverlay" class="overlay color-picker-overlay">
    <div id="colorPickerDialog" class="dialog color-picker-dialog">
      <label>Choose color:</label>
      <input type="color" id="colorPickerInput" />
      <button id="colorPickerOk">OK</button>
      <button id="colorPickerCancel">Cancel</button>
    </div>
  </div>

  <!-- Overlay: confirm remove -->
  <div id="confirmOverlay" class="overlay">
    <div id="confirmDialog" class="dialog">
      <p>Are you sure to remove this item?</p>
      <button id="confirmOk">Yes</button>
      <button id="confirmCancel">No</button>
    </div>
  </div>

  <!-- Overlay: info message -->
  <div id="infoOverlay" class="overlay">
    <div id="infoDialog" class="dialog">
      <p id="infoMessage"></p>
      <button id="infoOk">OK</button>
    </div>
  </div>

  <!-- Overlay: import dialog -->
  <div id="importDialogOverlay" class="overlay">
    <div id="importDialog" class="dialog import-dialog">
      <div class="header" id="importDialogHeader"></div>
      <div class="tabs">
        <button class="tab-button active" data-tab="generalTab">General</button>
        <button class="tab-button" data-tab="transparentColorsTab">Transparent colors</button>
      </div>
      <table style="width: 100%; height: calc(100% - 150px);">
        <tr>
          <td style="vertical-align: top; width: 70%; height: 100%;">
            <div id="generalTab" class="tab-content active" style="height: 100%;">
              <div id="import-specs">
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="objectColumns">Items quantity (Columns/Rows):</label>
                    <input type="number" id="objectColumns" value="0" />
                    <span>x</span>
                    <input type="number" id="objectRows" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="gapX">Gap (X/Y):</label>
                    <input type="number" id="gapX" value="0" />
                    <span>x</span>
                    <input type="number" id="gapY" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="posX">Start position (X/Y):</label>
                    <input type="number" id="posX" value="0" />
                    <span>x</span>
                    <input type="number" id="posY" value="0" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="paletteSelect">Palette:</label>
                    <select id="paletteSelect">
                      <option value="areaonlycolors">Create a new palette (only selected area colors)</option>
                      <option value="allimagecolors">Create a new palette (all image colors)</option>
                      <!-- Palette options will be populated dynamically -->
                    </select>
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="minColorsDistance">Color min. distancy (only for new palettes):</label>
                    <input type="number" id="minColorsDistance" value="1" min="1" max="255" />
                  </div>
                </div>
                <div class="form-group-container">
                  <div class="form-group">
                    <label for="importFile">Select PNG file:</label>
                    <input type="file" id="importFile" accept=".png, .bmp" />
                  </div>
                </div>
              </div>
              <div class="selected-image" style="height: 340px;" id="selectedImagePanel">
                <img id="selectedImage" src="" />
              </div>
            </div>
            <div id="transparentColorsTab" class="tab-content">
              <table class="transparent-colors">
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
                <tr>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                  <td><input type="text" maxlength="7" /></td>
                </tr>
              </table>
            </div>
          </td>
          <td style="vertical-align: top; width: 30%;">
            <div class="preview-panel" id="importedItemsPanel"></div>
          </td>
        </tr>
      </table>
      <div class="form-actions">
        <button id="importPreview" style="display: none;">Preview</button>
        <button id="importImport" style="display: none;">Import</button>
        <button id="importClose">Close</button>
      </div>
    </div>
  </div>

  <!-- Overlay: validation message -->
  <div id="validationOverlay" class="overlay">
    <div id="validationDialog" class="dialog">
      <p id="validationMessage"></p>
      <button id="validationOk">OK</button>
    </div>
  </div>

  <!-- Overlay: invalid image message -->
  <div id="invalidImageOverlay" class="overlay">
    <div id="invalidImageDialog" class="dialog">
      <p>Invalid image</p>
      <button id="invalidImageOk">OK</button>
    </div>
  </div>

<script src="./utils.js"></script>
<script src="./colorThief.js"></script>
<script>

/* ======================================================================================
   GLOBAL STATE
   ====================================================================================== */
let editModeActive = false; // if true => hide buttons in grid
let dataStore = [];
let tempPaletteColors = []; // Global variable to store temporary colors
const vscode = acquireVsCodeApi(); // Acquire VS Code API once
let importSpecs = {};
let croppedImages = []; // Global array to store cropped images
let importPreviewImages = [];
let importPreviewPalette = [];
let importPaletteID = -1;
let importPalette = []; // Global variable to store the palette used for import

let croppedImportImages = []; 
let noCroppedImportImages = [];
/* ======================================================================================
   MOCK DATA
   ====================================================================================== */

function loadDataStore(data) {
  dataStore = JSON.parse(data);
  updateGrid();
}

/* ======================================================================================
   SUPPORT FUNCTIONS
   ====================================================================================== */

function saveDataStore() {
  vscode.postMessage({
    command: 'saveDataStore',
    data: JSON.stringify(dataStore)
  });
}

/* ======================================================================================
   SUPPORT FUNCTIONS
   ====================================================================================== */

function getSubtypesForType(type) {
  if (type === "Sprites") {
    return ["Type 1", "Type 2"];
  }
  else if (type === "Tiles") {
    return ["Standard", "Bitmap"];
  }
  return [];
}

function getDependants(type, id) {
  return dataStore.filter(r => (r.ChildObjectType === type && r.ChildObjectID && r.ChildObjectID.toString() === id.toString()));
}

function getNextIDForType(type) {
  let max = 0;
  dataStore.forEach(r => {
    if (r.Type === type && r.ID > max) {
      max = r.ID;
    }
  });
  return max + 1;
}

function getChildObjectDescription(childType, childID) {
  if (!childType || !childID) return "";
  
  let rec= dataStore.find(r => r.Type === childType && r.ID.toString() === childID.toString());
  
  if (!rec) return "";
  return rec.Description;
}

/* ======================================================================================
   SUBTYPE + GRID MANAGEMENT
   ====================================================================================== */
function updateSubtypeCombo() {
  const type = document.getElementById("typeSelect").value;
  const subtypeCombo = document.getElementById("subtypeSelect");
  const subtypeLabel = document.getElementById("subtypeLabel");

  let subtypes = getSubtypesForType(type);
  if (subtypes.length > 0) {
    subtypeCombo.classList.remove("hidden");
    subtypeLabel.classList.remove("hidden");
    subtypeCombo.innerHTML = "";
    subtypes.forEach(st => {
      let opt = document.createElement("option");
      opt.value = st;
      opt.textContent = st;
      subtypeCombo.appendChild(opt);
    });
    subtypeCombo.selectedIndex = 0;
  } else {
    subtypeCombo.classList.add("hidden");
    subtypeLabel.classList.add("hidden");
    subtypeCombo.innerHTML = "";
  }
}

function updateGrid() {
  const type = document.getElementById("typeSelect").value;
  const subtypeCombo = document.getElementById("subtypeSelect");
  let subtype = "";
  if (!subtypeCombo.classList.contains("hidden")) {
    subtype = subtypeCombo.value;
  }
  renderGrid(type, subtype);
}

/* ======================================================================================
   RENDER GRID
   ====================================================================================== */
function renderGrid(typeFilter, subtypeFilter) {
  const tbody = document.querySelector("#dataGrid tbody");
  const theadRow = document.getElementById("gridHeader");
  tbody.innerHTML = "";
  theadRow.innerHTML = "";
  if(dataStore===null){
    return;
  }
  let columns = [];
  switch (typeFilter) {
    case "Sprites":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
    case "Tiles":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
    case "Maps":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Tile", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
    case "Fonts":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Spaces (W/H)", field: "FontSpaces" },
        { label: "First char", field: "FirstFontChar" },
        { label: "Last char", field: "LastFontChar" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
    case "Animations":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Sprite/Tile", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
    case "Palettes":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Colors", field: "Values" }
      ];
      break;
    case "Images":
      columns = [
        { label: "ID", field: "ID" },
        { label: "Description", field: "Description" },
        { label: "Size (W/H)", field: "Size" },
        { label: "Palette", field: "ChildObjectID" },
        { label: "Items", field: "ValuesCount" } // New column
      ];
      break;
  }

  // Create the header
  columns.forEach(col => {
    let th = document.createElement("th");
    th.textContent = col.label;
    theadRow.appendChild(th);
  });
  let thAction = document.createElement("th");
  thAction.textContent = "Actions";
  theadRow.appendChild(thAction);

  // Filter dataStore
  let filteredData = dataStore.filter(row => {
    if (row.Type !== typeFilter) return false;
    if (getSubtypesForType(typeFilter).length > 0) {
      return (row.Subtype === subtypeFilter);
    }
    return (row.Subtype === "");
  });

  // Rows
  filteredData.forEach(row => {
    let tr = document.createElement("tr");

    columns.forEach(col => {
      let td = document.createElement("td");

      if (col.field === "ChildObjectID") {
        // get the description of the child object
        let objDesc = getChildObjectDescription(row.ChildObjectType, row.ChildObjectID);
        // if Animations => add (S) or (T)
        if (typeFilter === "Animations") {
          if (row.ChildObjectType === "Sprites") {
            objDesc += " (Sprite)";
          } else if (row.ChildObjectType === "Tiles") {
            objDesc += " (Tile)";
          }
        }
        td.textContent = objDesc;
      }
      else if (col.field === "Values" && typeFilter === "Palettes") {
        // 16 squares
        try {
          
          let valArr =row.Values;
          valArr.forEach(c => {
            let colorDiv = document.createElement("span");
            colorDiv.className = "color-square";
            let hexID = (c.id + "").toUpperCase();
            if (hexID === "0") {
              colorDiv.classList.add("checkerboard");
              colorDiv.style.cursor = "default";
            } else {
              colorDiv.style.backgroundColor = c.color;
            }
            colorDiv.title = `RGB: ${c.color}\nMSX: ${rgbToMsx(c.color)}`;

            let labelSpan = document.createElement("span");
            labelSpan.textContent = hexID;
            let isDark = computeBrightness(c.color) < 128;
            labelSpan.style.color = isDark ? "#fff" : "#000";
            if (hexID === "0") {
              labelSpan.style.color = "#444";
            }
            colorDiv.appendChild(labelSpan);
            td.appendChild(colorDiv);
          });
        } catch(e) {
          console.log ("ERROR", e);
          td.textContent = "Invalid JSON Colors";
        }
      }
      else if (col.field === "ValuesCount") {
        // New column logic
        td.textContent = row.Values ? row.Values.length : 0;
      }
      else if (typeFilter === "Fonts" && col.field === "FontSpaces") {
        // If FontSpaces is empty => "0x0"
        if (!row.FontSpaces) {
          td.textContent = "0x0";
        } else {
          td.textContent = row.FontSpaces;
        }
      }
      else {
        // generic
        td.textContent = row[col.field] || "";
      }

      tr.appendChild(td);
    });

    // Actions column
    let tdActions = document.createElement("td");
    if (!editModeActive) {
      // Edit button
      let editBtn = document.createElement("button");
      editBtn.className = "action-button";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", () => {
        console.log("Clicked Edit on record:", row);
        openEditDialog(row, false);
      });
      tdActions.appendChild(editBtn);

      // Remove button
      let removeBtn = document.createElement("button");
      removeBtn.className = "action-button";
      removeBtn.textContent = "Remove";
      let isRef = getDependants(row.Type, row.ID).length > 0;
      if (isRef) {
        removeBtn.style.display = "none";
      }
      // if Palettes => do not remove if there is only 1
      let totalPal = dataStore.filter(r => r.Type === "Palettes").length;
      if (row.Type === "Palettes" && totalPal <= 1) {
        removeBtn.style.display = "none";
      }
      removeBtn.addEventListener("click", () => {
        console.log("Clicked Remove on record:", row);
        if(row.Type === "Sprites" || row.Type === "Tiles"){
          let dependants = getDependants(row.Type, row.ID);
          if(dependants.length > 0){
            openInfoDialog("You can't remove the record because it is used by \"" + dependants[0].Name + "\" " + dependants[0].Type, null);
            return;
          }
          
        }
        openConfirmDialog(() => {
          dataStore = dataStore.filter(r => !(r.Type === row.Type && r.ID === row.ID));
          saveDataStore();
          updateGrid();
        });
      });
      tdActions.appendChild(removeBtn);

      // Import button
      if ((row.Type === "Sprites" && row.Subtype=="Type 1") || row.Type === "Tiles" || row.Type === "Fonts" || row.Type === "Images" ) {
        let importBtn = document.createElement("button");
        importBtn.className = "action-button imports-button";
        importBtn.textContent = "Import...";
        importBtn.dataset.recordId = row.ID;
        tdActions.appendChild(importBtn);
      }

      // Details button (except Palettes)
      if (row.Type !== "Palettes" && row.ChildObjectID !== "-1") {
        let detailsBtn = document.createElement("button");
        detailsBtn.className = "action-button details-button";
        detailsBtn.textContent = "Collection...";
        detailsBtn.dataset.recordId = row.ID;
        tdActions.appendChild(detailsBtn);
      }
    }
    tr.appendChild(tdActions);

    tbody.appendChild(tr);
  });
}

/* ======================================================================================
   OPEN EDIT DIALOG
   ====================================================================================== */
function openEditDialog(existingRow, createNew) {
  console.log("openEditDialog, createNew=", createNew);
  const dialog = document.getElementById("editDialog");
  dialog.innerHTML = "";
  dialog.classList.remove("hidden");

  // Hide "New" button
  document.getElementById("addButton").classList.add("hidden");

  editModeActive = true;
  updateGrid();

  // Disable Type and Subtype
  document.getElementById("typeSelect").disabled = true;
  document.getElementById("subtypeSelect").disabled = true;

  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }

  let tempRow = {};
  if (createNew) {
    tempRow.Type = currentType;
    tempRow.Subtype = getSubtypesForType(currentType).length > 0 ? currentSubtype : "";
    tempRow.ID = getNextIDForType(currentType);
    tempRow.Description = "";
    tempRow.Size = "";
    tempRow.EditingSettings = "";
    tempRow.ChildObjectType = "";
    tempRow.ChildObjectID = null;
    tempRow.Values = "";
    tempRow.FirstFontChar = "";
    tempRow.LastFontChar = "";
    tempRow.FontSpaces = "";

    // if Palettes => default colors
    if (currentType === "Palettes") {
      tempRow.Values = getDefaultMSXColors(false);
      tempPaletteColors = [...tempRow.Values]; // Assign initial palette
    }
    // if Sprites => size=8x8
    if (currentType === "Sprites") {
      tempRow.Size = "8x8";
    }
    // if Tiles and subtype=Bitmap => size=8x8
    if (currentType === "Tiles" && currentSubtype === "Bitmap") {
      tempRow.Size = "8x8";
    }
    // if Images => size=100x100
    if (currentType === "Images") {
      tempRow.Size = "100x100";
    }
    // if Fonts => size=8x8
    if (currentType === "Fonts") {
      tempRow.Size = "8x8";
      tempRow.FontSpaces = "0x0";
    }
    if (currentType === "Maps") {
      tempRow.Size = "10x10";
    }

    
  } else {
    // Shallow copy
    tempRow = { ...existingRow };
    if (currentType === "Palettes") {
      tempPaletteColors = [...tempRow.Values]; // Assign existing palette
    }
  }

  let fields = getFieldsForType(currentType, tempRow, createNew);
  fields.forEach(f => {
    let divWrap = document.createElement("div");
    divWrap.className = "form-group";
    let fieldLabel = document.createElement("label");
    fieldLabel.textContent = f.label;
    let fieldInput = null;

    switch (f.type) {
      case "text":
        fieldInput = document.createElement("input");
        fieldInput.type = "text";
        fieldInput.value = tempRow[f.name] || "";
        if (f.maxLength) {
          fieldInput.maxLength = f.maxLength;
        }
        fieldInput.disabled = !!f.disabled;
        fieldInput.addEventListener("input", e => {
          tempRow[f.name] = e.target.value;
        });
        break;

      case "spinpair":
      case "spinpair-fontspaces":
        let [w, h] = (tempRow[f.name] || "0x0").split("x");
        let spinW = document.createElement("input");
        spinW.type = "number";
        spinW.min = f.min; spinW.max = f.max; spinW.step = f.step;
        spinW.value = w || 0;
        spinW.disabled = !!f.disabled;

        let spinH = document.createElement("input");
        spinH.type = "number";
        spinH.min = f.min; spinH.max = f.max; spinH.step = f.step;
        spinH.value = h || 0;
        spinH.disabled = !!f.disabled;

        spinW.addEventListener("change", () => {
          tempRow[f.name] = spinW.value + "x" + spinH.value;
          
        });
        spinH.addEventListener("change", () => {
        
          tempRow[f.name] = spinW.value + "x" + spinH.value;
          
        });

        fieldInput = document.createElement("span");
        fieldInput.appendChild(spinW);
        fieldInput.appendChild(document.createTextNode(" x "));
        fieldInput.appendChild(spinH);
        break;

      case "char":
        fieldInput = document.createElement("input");
        fieldInput.type = "text";
        fieldInput.maxLength = 1;
        fieldInput.value = tempRow[f.name] || "";
        fieldInput.disabled = !!f.disabled;
        fieldInput.addEventListener("input", e => {
          if (e.target.value.length > 1) {
            e.target.value = e.target.value.slice(0,1);
          }
          tempRow[f.name] = e.target.value;
        });
        break;

      case "combobox":
        fieldInput = document.createElement("select");
        fieldInput.disabled = !!f.disabled;
        f.options.forEach(opt => {
          let o = document.createElement("option");
          o.value = opt.value;
          o.textContent = opt.label;
          fieldInput.appendChild(o);
        });
        fieldInput.value = tempRow[f.name] || "";
        fieldInput.addEventListener("change", e => {
          tempRow[f.name] = e.target.value;
        });
        break;

      case "palette-colors-editor":
        fieldInput = document.createElement("div");
        renderPaletteEditor(fieldInput, tempRow);
        break;
    }

    divWrap.appendChild(fieldLabel);
    if (fieldInput) divWrap.appendChild(fieldInput);
    dialog.appendChild(divWrap);
  });

  // Save/Cancel buttons
  let divActions = document.createElement("div");
  divActions.className = "form-group";
  let saveBtn = document.createElement("button");
  saveBtn.textContent = "Save";
  saveBtn.addEventListener("click", () => {
    console.log("Clicked SAVE; createNew=", createNew, "tempRow=", tempRow);

    // If Animations in edit mode => user can only change description
    if (currentType === "Animations" && !createNew) {
      tempRow.ChildObjectID = existingRow.ChildObjectID;
      tempRow.ChildObjectType = existingRow.ChildObjectType;
    }

    // Minimum validation
    if (!tempRow.Description) {
      openInfoDialog("Description is required!", null);
      return;
    }

    // Example of size validations
    if (!checkSizeConstraints(currentType, currentSubtype, tempRow)) {
      return;
    }

    // Animations createNew => "childID_suffix"
    if (currentType === "Animations" && createNew) {
      let rawVal = tempRow.ChildObjectID || "";
      let parts = rawVal.split("_");
      if (parts.length === 2) {
        let childID = parseInt(parts[0], 10);
        let suffix = parts[1];
        if (suffix === "S") {
          tempRow.ChildObjectType = "Sprites";
        } else if (suffix === "T") {
          tempRow.ChildObjectType = "Tiles";
        } else {
          openInfoDialog("Invalid suffix in Sprite/Tile combo!", null);
          return;
        }
        tempRow.ChildObjectID = childID;
      } else {
        openInfoDialog("Please select a valid Sprite/Tile in combo!", null);
        return;
      }
    }

    // Other types => ChildObjectType based on rules
    if (!createNew && currentType === "Animations") {
      // do nothing
    } else if (["Sprites","Tiles","Fonts","Images"].includes(currentType)) {
      tempRow.ChildObjectType = "Palettes";
    } else if (currentType === "Maps") {
      tempRow.ChildObjectType = "Tiles";
    }

    // Required fields validation
    let requiredFields = getRequiredFieldsForType(currentType);
    for (let field of requiredFields) {
      if (tempRow[field] === undefined || tempRow[field] === null || tempRow[field] === "") {
        openInfoDialog(`${getFieldNames(currentType, field)} is required!`, null);
        return;
      }
    }

    // Save
    if (createNew) {
      if (createNew && currentType !== "Palettes" && currentType !== "Animations") {
          
        tempRow.EditingSettings={
          "GridEditorZoom":currentType === "Images"?0.1:1.25,
          "ObjectsGridZoom":1.25,
          "ObjectsGridBackgroundColor":"#010101",
          "PatternsGridZoom":1,
          "PatternGridBackgroundColor":"#010101",
          "PreviewZoom":1.25,
          "PreviewdBackgroundColor":"#010101",
          "GridEditorZoom":1.25,
          "ShowGrid":true,
          "Show8x8Blocks":true
        };

        
        

  
        
      }
      dataStore.push(tempRow);
    } else {
      let idx = dataStore.findIndex(r => r.Type === existingRow.Type && r.ID === existingRow.ID);
      if (idx >= 0) {
        dataStore[idx] = tempRow;
      }
    }

    saveDataStore();
    dialog.classList.add("hidden");
    document.getElementById("typeSelect").disabled = false;
    document.getElementById("subtypeSelect").disabled = false;
    editModeActive = false;
    updateGrid();

    // Show "New" button
    document.getElementById("addButton").classList.remove("hidden");
  });
  divActions.appendChild(saveBtn);

  let cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.addEventListener("click", () => {
    console.log("Clicked CANCEL");
    dialog.classList.add("hidden");
    document.getElementById("typeSelect").disabled = false;
    document.getElementById("subtypeSelect").disabled = false;
    editModeActive = false;
    updateGrid();

    // Show "New" button
    document.getElementById("addButton").classList.remove("hidden");
  });
  divActions.appendChild(cancelBtn);

  dialog.appendChild(divActions);
}

/* ======================================================================================
   SIZE VALIDATION FUNCTION
   ====================================================================================== */
function checkSizeConstraints(type, subtype, row) {
  if (!row.Size) return true;

  let [w, h] = row.Size.split("x");
  let wNum = parseInt(w, 10) || 0;
  let hNum = parseInt(h, 10) || 0;

  if (type === "Sprites") {
    // Sprites validation (already present)
    if (wNum < 8 || wNum > 64 || hNum < 8 || hNum > 64) {
      openInfoDialog("Sprites size must be in [8..64]!", null);
      return false;
    }
    if (wNum % 8 !== 0 || hNum % 8 !== 0) {
      openInfoDialog("Sprites size must be multiples of 8", null);
      return false;
    }
  }
  else if (type === "Tiles" && subtype === "Bitmap") {
    // Tiles bitmap validation (already present)
    if (wNum < 4 || wNum > 64 || hNum < 4 || hNum > 64) {
      openInfoDialog("Tiles Bitmap size must be in [4..64]", null);
      return false;
    }
  }
  else if (type === "Images") {
     if (wNum > 256 || wNum < 30 ) {
      openInfoDialog("Images width size must be in [30..256]", null);
      return false;
    }
    if (hNum > 212 ||hNum < 30) {
      openInfoDialog("Images height size must be in [30..212]", null);
      return false;
    }

  }
  else if (type === "Fonts") {
    // REQUEST: minimum size 50x50, maximum 1024x512
    if (wNum > 20 || hNum > 20 || wNum < 8 || hNum < 8) {
      openInfoDialog("Fonts size must be in [8..20]", null);
      return false;
    }
  }
  else if (type === "Maps") {
    // REQUEST: minimum size 50x50, maximum 1024x512
    if (wNum > 100 || hNum > 100 || wNum < 2 || hNum < 2) {
      openInfoDialog("Maps size must be in [2..100]", null);
      return false;
    }
  }
  return true;
}

/* ======================================================================================
   getFieldsForType
   ====================================================================================== */
function getFieldsForType(type, row, createNew) {
  let fields = [
    { label: "ID: ", name: "ID", type: "text", disabled: true },
    { label: "Description: ", name: "Description", type: "text", maxLength: 255 }
  ];

  if (type === "Sprites") {
    // size enabled if createNew
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 8,
      max: 64,
      step: 8,
      disabled: !createNew
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Tiles") {
    let isStandard = (row.Subtype === "Standard");
    let sizeDisabled = false;
    let step = 1;
    let minVal = 1;
    let maxVal = 64;

    if (!createNew) {
      sizeDisabled = true;
    } else {
      sizeDisabled = isStandard;
      if (isStandard && !row.Size) {
        row.Size = "8x8";
      }
    }
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: minVal,
      max: maxVal,
      step: step,
      disabled: sizeDisabled
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Maps") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 64,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Tile: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getTileOptions(),
      disabled: false
    });
  }
  else if (type === "Fonts") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 20,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Spaces (W/H): ",
      name: "FontSpaces",
      type: "spinpair-fontspaces",
      min: 1,
      max: 20,
      step: 1,
      disabled: false
    });
    fields.push({
      label: "First character: ",
      name: "FirstFontChar",
      type: "char",
      disabled: false
    });
    fields.push({
      label: "Last character: ",
      name: "LastFontChar",
      type: "char",
      disabled: false
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Palettes") {
    fields.push({
      label: "Colors: ",
      name: "Values",
      type: "palette-colors-editor"
    });
  }
  else if (type === "Images") {
    fields.push({
      label: "Size (W/H): ",
      name: "Size",
      type: "spinpair",
      min: 1,
      max: 512,
      step: 1,
      disabled: !createNew
    });
    fields.push({
      label: "Palette: ",
      name: "ChildObjectID",
      type: "combobox",
      options: getPaletteOptions(createNew || (row.Values && row.Values.length === 0)),
      disabled: false
    });
  }
  else if (type === "Animations") {
    // if createNew => combo, if edit => no combo
    if (createNew) {
      fields.push({
        label: "Sprite/Tile: ",
        name: "ChildObjectID",
        type: "combobox",
        options: getSpriteTileOptionsWithSuffix(),
        disabled: false
      });
    }
  }

  return fields;
}

/* ======================================================================================
   COMBO UTILS
   ====================================================================================== */

function getPaletteOptions(includeNotSelected = false) {
  let list = dataStore.filter(r => r.Type === "Palettes");
  let options = list.map(r => ({ value: r.ID, label: r.Description }));
  if (includeNotSelected) {
    options.unshift({ value: -1, label: "Not selected" });
  }
  return options;
}

function getTileOptions() {
  let list = dataStore.filter(r => r.Type === "Tiles");
  return list.map(r => ({ value: r.ID, label: r.Description }));
}

function getSpriteTileOptionsWithSuffix() {
  // for Animations => "ID_S" or "ID_T"
  let list = dataStore.filter(r => r.Type === "Sprites" || r.Type === "Tiles");
  return list.map(r => {
    let suffix = (r.Type === "Sprites") ? "S" : "T";
    let labelSuffix = (r.Type === "Sprites") ? "(Sprite)" : "(Tile)";
    return {
      value: r.ID + "_" + suffix,
      label: r.Description + " " + labelSuffix
    };
  });
}

/* ======================================================================================
   EDITOR OF "PALETTE-COLORS-EDITOR"
   ====================================================================================== */
function renderPaletteEditor(container, tempRow) {
  let paletteArray = [];
  if (tempRow.Values) {
    try {
      paletteArray = tempRow.Values;
    } catch (e) {
      paletteArray = getDefaultMSXColors(false);
    }
  } else {
    paletteArray = getDefaultMSXColors(false);
  }
  tempPaletteColors = [...paletteArray]; // Copy colors to global variable

  tempPaletteColors.forEach(colObj => {
    let box = document.createElement("span");
    box.className = "color-square";
    let colorCode = colObj.color.toUpperCase();
    let hexID = (colObj.id + "").toUpperCase();
    box.title = `RGB: ${colorCode}\nMSX: ${rgbToMsx(colorCode)}`;

    if (hexID === "0") {
      box.classList.add("checkerboard");
      box.style.cursor = "default";
    } else {
      box.style.backgroundColor = colorCode;
      box.addEventListener("click", () => {
        openColorPickerDialog(colorCode, newColor => {
          colObj.color = newColor;
          box.style.backgroundColor = newColor;
          let labelSpan = box.querySelector("span");
          let isDark = computeBrightness(newColor) < 128;
          labelSpan.style.color = isDark ? "#fff" : "#000";
          // Update the tooltip with the new color
          box.title = `RGB: ${newColor}\nMSX: ${rgbToMsx(newColor)}`;
        });
      });
    }

    let labelSpan = document.createElement("span");
    labelSpan.textContent = hexID;
    let isDark = computeBrightness(colorCode) < 128;
    labelSpan.style.color = isDark ? "#fff" : "#000";
    if (hexID === "0") {
      labelSpan.style.color = "#444";
    }
    box.appendChild(labelSpan);

    container.appendChild(box);
  });
}

function getDefaultMSXColors(isMSX2) {
  if(isMSX2){
    return [
      { id: "0", color: "#000000" },
      { id: "1", color: "#010101" },
      { id: "2", color: "#21C842" },
      { id: "3", color: "#5EDC78" },
      { id: "4", color: "#5455ED" },
      { id: "5", color: "#7D76FC" },
      { id: "6", color: "#D4524D" },
      { id: "7", color: "#42EBF5" },
      { id: "8", color: "#FC5554" },
      { id: "9", color: "#FF7978" },
      { id: "A", color: "#D4C154" },
      { id: "B", color: "#E6CE80" },
      { id: "C", color: "#21B03B" },
      { id: "D", color: "#C95BBA" },
      { id: "E", color: "#CCCCCC" },
      { id: "F", color: "#FFFFFF" }
    ];
  }
  else{
    return [
      { id: "0", color: "#000000" },
      { id: "1", color: "#010101" },
      { id: "2", color: "#3EB849" },
      { id: "3", color: "#74D07D" },
      { id: "4", color: "#5955E0" },
      { id: "5", color: "#8076F1" },
      { id: "6", color: "#B95E51" },
      { id: "7", color: "#65DBEF" },
      { id: "8", color: "#DB6559" },
      { id: "9", color: "#FF897D" },
      { id: "A", color: "#CCC35E" },
      { id: "B", color: "#DED087" },
      { id: "C", color: "#3AA241" },
      { id: "D", color: "#B766B5" },
      { id: "E", color: "#CCCCCC" },
      { id: "F", color: "#FFFFFF" }
    ];
  }
}

/* ======================================================================================
   COLOR PICKER
   ====================================================================================== */
function openColorPickerDialog(initialColor, callback) {

  const overlay = document.getElementById("colorPickerOverlay");
  const colorInput = document.getElementById("colorPickerInput");
  const okBtn = document.getElementById("colorPickerOk");
  const cancelBtn = document.getElementById("colorPickerCancel");

  overlay.style.display = "flex";
  colorInput.value = rgbToHex(initialColor);

  function onOk() {
    let newColor = colorInput.value.toUpperCase();
    if(newColor==="#000000"){
      newColor="#010101";
    }
    callback(newColor);
    closeColorPickerOverlay();
  }

  function onCancel() {
    closeColorPickerOverlay();
  }

  function closeColorPickerOverlay() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);

  }

  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);

  // Detect color under mouse pointer
  overlay.addEventListener("mousemove", (e) => {
    const color = getColorAtMousePosition(e.clientX, e.clientY);
    if (color) {
      colorInput.value = rgbToHex(color);
    }
  });
}

function getColorAtMousePosition(x, y) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = 1;
  canvas.height = 1;
  const element = document.elementFromPoint(x, y);
  if (element && (element.tagName === "IMG" || element.tagName === "CANVAS")) {
    context.drawImage(element, -x, -y);
    const pixel = context.getImageData(0, 0, 1, 1).data;
    return `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
  }
  return null;
}

function focusOnColorSquare() {
  const colorSquare = document.querySelector('.color-square[style*="background-color"]');
  if (colorSquare) {
    colorSquare.focus();
  }
}

/* ======================================================================================
   CONFIRM DIALOG
   ====================================================================================== */
function openConfirmDialog(onConfirm) {
  console.log("openConfirmDialog");
  const overlay = document.getElementById("confirmOverlay");
  const okBtn = document.getElementById("confirmOk");
  const cancelBtn = document.getElementById("confirmCancel");

  overlay.style.display = "flex";

  let onOk = () => {
    closeConfirm();
    onConfirm();
  };
  let onCancel = () => {
    closeConfirm();
  };
  function closeConfirm() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);
  }
  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);
}

/* ======================================================================================
   INFO DIALOG
   ====================================================================================== */
function openInfoDialog(message, onClose) {
  console.log("openInfoDialog", message);
  const overlay = document.getElementById("infoOverlay");
  const msg = document.getElementById("infoMessage");
  const okBtn = document.getElementById("infoOk");

  msg.textContent = message;
  overlay.style.display = "flex";

  let onOk = () => {
    closeInfo();
    if (onClose) onClose();
  };
  function closeInfo() {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
  }
  okBtn.addEventListener("click", onOk);
}

/* ======================================================================================
   COLOR UTILITY
   ====================================================================================== */
function computeBrightness(hex) {
  let c = hex.replace("#","");
  if (c.length < 6) return 255;
  let r = parseInt(c.substring(0,2), 16);
  let g = parseInt(c.substring(2,4), 16);
  let b = parseInt(c.substring(4,6), 16);
  return (0.299*r + 0.587*g + 0.114*b);
}

//function rgbToHex(rgb) {
//  let hex = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
//  function hexify(x) {
//    return ("0" + parseInt(x).toString(16)).slice(-2).toUpperCase();
//  }
//  return "#" + hexify(hex[1]) + hexify(hex[2]) + hexify(hex[3]);
//}

/* ======================================================================================
   EVENT LISTENERS (on load)
   ====================================================================================== */
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM loaded");
  document.getElementById("typeSelect").value = "Sprites";
  updateSubtypeCombo();
  updateGrid();

  document.getElementById("typeSelect").addEventListener("change", () => {
    updateSubtypeCombo();
    updateGrid();
  });
  document.getElementById("subtypeSelect").addEventListener("change", () => {
    updateGrid();
  });

  document.getElementById("addButton").addEventListener("click", () => {
    console.log("Clicked ADD new record");
    openEditDialog(null, true);
  });

  // Listen for messages from the extension
  window.addEventListener('message', event => {
    const message = event.data;
    switch (message.command) {
      case 'loadDataStore':
        loadDataStore(message.data);
        break;
      case 'returnFromDetails':
        const data = JSON.parse(message.data);
        console.log("returnFromDetails", data);
        // Update the data store with the reloaded data
        dataStore = data;
        // Apply filters based on the record's type and subtype
        applyFilters(message.record.Type, message.record.Subtype);
        // Update the grid with the reloaded data
        updateGrid();
        // Scroll to the specific record
        scrollToRecord(message.record);
        break;
      case 'closeDetailsView':
          //updateRecord(message.record,message.action);
        break;
    }
  });



  document.getElementById("dataGrid").addEventListener("click", (e) => {
    if (e.target.classList.contains("details-button")) {
      const recordId = e.target.dataset.recordId;
      const currentType = document.getElementById("typeSelect").value;
      let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
      const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
      openDetailsView(record);
    }
  });

  document.getElementById("dataGrid").addEventListener("click", (e) => {
    if (e.target.classList.contains("imports-button")) {
      const recordId = e.target.dataset.recordId;
      const currentType = document.getElementById("typeSelect").value;
      let currentSubtype = "";
      if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
        currentSubtype = document.getElementById("subtypeSelect").value;
      }
      const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
      openImportDialog(record);
    }
  });
 
  document.addEventListener("keydown", (e) => {
    if (e.ctrlKey && (e.key === "+" || e.key === "-" || e.key === "=")) {
      e.preventDefault();
      zoomLevel += (e.key === "+" || e.key === "=") ? 0.1 : -0.1;
      zoomLevel = Math.max(0.1, zoomLevel);
      updateZoom();
    }
  });

  document.addEventListener("wheel", (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      zoomLevel += e.deltaY < 0 ? 0.1 : -0.1;
      zoomLevel = Math.max(0.1, 0.1);
      updateZoom();
    }
  });

  function updateZoom() {
    document.querySelectorAll(".image-grid img").forEach(img => {
      img.style.width = `${parseInt(img.style.width) * zoomLevel}px`;
      img.style.height = `${parseInt(img.style.height) * zoomLevel}px`;
    });
  }

  //const splitter = document.getElementById("splitter");

  //splitter.addEventListener("mousedown", (e) => {
  //  e.preventDefault();
  //  document.addEventListener("mousemove", resizePanes);
  //  document.addEventListener("mouseup", () => {
  //    document.removeEventListener("mousemove", resizePanes);
  //  });
  //});

 //function resizePanes(e) {
 //  const leftPane = document.querySelector(".images-panel");
 //  const rightPane = document.querySelector(".drawing-panel");
 //  const totalWidth = leftPane.offsetWidth + rightPane.offsetWidth;
 //  const leftWidth = e.clientX / totalWidth * 100;
 //  leftPane.style.flex = `0 0 ${leftWidth}%`;
 //  rightPane.style.flex = `0 0 ${100 - leftWidth}%`;
 //}

  //const splitterHorizontal = document.getElementById("splitterHorizontal");
 //splitterHorizontal.addEventListener("mousedown", (e) => {
 //  e.preventDefault();
 //  document.addEventListener("mousemove", resizeHorizontalPanes);
 //  document.addEventListener("mouseup", () => {
 //    document.removeEventListener("mousemove", resizeHorizontalPanes);
 //  });
 //});

  function resizeHorizontalPanes(e) {
    const topPane = document.querySelector(".image-grid-panel");
    const bottomPane = document.querySelector(".patterns-grid-panel");
    const totalHeight = topPane.offsetHeight + bottomPane.offsetHeight;
    const topHeight = e.clientY / totalHeight * 100;
    topPane.style.flex = `0 0 ${topHeight}%`;
    bottomPane.style.flex = `0 0 ${100 - topHeight}%`;
  }
});

/* ======================================================================================
   OPEN DETAILS VIEW
   ====================================================================================== */
let zoomLevel = 1;
let focusedImage = null;
let backgroundColor = "#ffffff";
let patternsBackgroundColor = "#ffffff";

function openDetailsView(record) {
  let command='openDetailsView';
  const childRecord = dataStore.find(r => r.Type === record.ChildObjectType && r.ID.toString() === record.ChildObjectID.toString());
  let spriteTilePaletteRecord=[];
  if(record.Type==="Animations" || record.Type==="Maps"){
    spriteTilePaletteRecord=dataStore.find(r => r.Type === childRecord.ChildObjectType && r.ID.toString() === childRecord.ChildObjectID.toString());
    console.log("spriteTilePaletteRecord",spriteTilePaletteRecord);
    console.log("childRecord",childRecord);
    if(childRecord.Values===null || childRecord.Values===undefined || childRecord.Values.length===0){
      openInfoDialog("No items in \"" + childRecord.Description + "\" " + childRecord.Type.toLowerCase() + " sets", null);
      return;
    }
    command=record.Type=="Animations"?"openAnimationsDetailsView":"openMapsDetailsView";
  }
  vscode.postMessage({
    command: command,
    record: record,
    childRecord: childRecord,
    spriteTilePaletteRecord: spriteTilePaletteRecord,
    dataStore: dataStore
  });
}

function closeDetailsView() {
  document.getElementById("mainPanel").classList.add("active");
  document.getElementById("detailsPanel").classList.remove("active");
}


// ==========
// ColorThief
// ==========

function getDominantColorsFromDataUrl(base64Image, distancy,croppedImage,transparentColors,size){
    
    const colorThief = new ColorThief();
    const img = new Image();
   
    img.onload = () => {
     
        var palette = colorThief.getPalette(img, 15, 0); 
        
        palette = filterSimilarColors(palette, distancy);
        const hexPalette = palette.map(color => {
            return ('#' + ((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1)).toUpperCase();
        });
      
        importItemsFromImage(hexPalette,croppedImage,transparentColors,size);
    };


    console.log("QUI3");
    var quality = 10;
    img.src = base64Image; 
    console.log(base64Image);
};

function colorDistance(color1, color2) {
    const rDiff = color1[0] - color2[0];
    const gDiff = color1[1] - color2[1];
    const bDiff = color1[2] - color2[2];
    return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
}


function filterSimilarColors(colors, minDistance = 50) {
    const filteredColors = [];

    colors.forEach(color => {
        let isSimilar = false;

        for (const filteredColor of filteredColors) {
            if (colorDistance(color, filteredColor) < minDistance) {
                isSimilar = true;
                break;
            }
        }

        if (!isSimilar) {
            filteredColors.push(color);
        }
    });

    return filteredColors;
}
function updateCroppedImageDescription(id, newDescription) {
  const image = croppedImages.find(img => img.id === id);
  if (image) {
    image.description = newDescription;
  }
}
function highlightRow(row) {
  document.querySelectorAll(".imported-item-row").forEach(r => {
    r.style.border = "none";
  });
  row.style.border = "3px solid red";
}

function importItemsFromImage(hexPalette, croppedImage, transparentColors, size) {
  console.log(hexPalette);
  importPaletteID = -1; // Reset importPaletteID
  //importHexPalette = hexPalette; // Save the palette to the global variable
  const [itemWidth, itemHeight] = size;
  const objectColumns = parseInt(document.getElementById("objectColumns").value, 10);
  const objectRows = parseInt(document.getElementById("objectRows").value, 10);
  const gapX = parseInt(document.getElementById("gapX").value, 10);
  const gapY = parseInt(document.getElementById("gapY").value, 10);
  const posX = parseInt(document.getElementById("posX").value, 10);
  const posY = parseInt(document.getElementById("posY").value, 10);

  
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const img = new Image();
  
  img.onload = () => {
    console.log("Src Image:", img.src);
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Create an array to store all pixels that have transparency
    const transparentPixels = [];

    for (let i = 0; i < data.length; i += 4) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0) {
        data[i] = 1;
        data[i + 1] = 1;
        data[i + 2] = 1;
      }
      if (data[i + 3] < 255) {
        transparentPixels.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // 2. Ensure #000000 is the first element of hexPalette if it exists, otherwise add it
    hexPalette = hexPalette.filter(color => color !== "#000000");
    hexPalette.unshift("#000000");
    if (!hexPalette.includes("#000000")) {
      hexPalette.unshift("#000000");
    }

    // 3. Ensure hexPalette has at least 16 elements
    while (hexPalette.length < 16) {
      hexPalette.push("#FFFFFF");
    }

    // Check if a palette from records is selected
    const selectedPaletteID = document.getElementById("paletteSelect").value;
    if (selectedPaletteID !== "areaonlycolors" && selectedPaletteID !== "allimagecolors") {
      const selectedPalette = dataStore.find(p => p.Type === "Palettes" && p.ID.toString() === selectedPaletteID);
      if (selectedPalette) {
        hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
        importPaletteID = selectedPalette.ID;
      }
    }
    //else{
    //  const selectedPalette = dataStore.find(p => p.Type === "Palettes");
    //  hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
    //  console.log("hexPalette",hexPalette);
    //}
    // 5. Replace pixels in croppedImage with colors in transparentColors to fully transparent
    //for (let i = 0; i < data.length; i += 4) {
    //  const pixelColor = `#${((1 << 24) + (data[i] << 16) + (data[i + 1] << 8) + data[i + 2]).toString(16).slice(1).toUpperCase()}`;
    //  if (transparentColors.includes(pixelColor)) {
    //    data[i + 3] = 0; // Set alpha channel to 0 (fully transparent)
    //    if (!transparentPixels.includes([data[i], data[i + 1], data[i + 2], data[i + 3]])) {
    //      transparentPixels.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);
    //    }
    //  }
    //}
    //ctx.putImageData(imageData, 0, 0);
    importPalette=hexPalette;
    // 6. Generate a new base64 image from croppedImage using the closest color in hexPalette
    for (let i = 0; i < data.length; i += 4) {
      const pixelColor = [data[i], data[i + 1], data[i + 2]];
      const closestColor = getClosestColor(pixelColor, hexPalette);
      const [r, g, b] = closestColor;
      data[i] = r;
      data[i + 1] = g;
      data[i + 2] = b;
    }
    ctx.putImageData(imageData, 0, 0);
    const newBase64Image = canvas.toDataURL();
    console.log("New Base64 Image:", newBase64Image);

    // Create cropped images and fill the importedItemsPanel
    const importedItemsPanel = document.getElementById("importedItemsPanel");
    importedItemsPanel.innerHTML = ""; // Clear previous content
    importPreviewImages = []; // Clear previous cropped images

    // Create a table to hold the color squares and the grid
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.height = "300px";

    // Create the first row for color squares
    const colorRow = document.createElement("tr");
    const colorCell = document.createElement("td");
    colorCell.style.height = "auto";
    const colorSquaresContainer = document.createElement("div");
    colorSquaresContainer.className = "color-squares-container";
    colorSquaresContainer.style.textAlign = "center";
    hexPalette.forEach((color, index) => {
      const colorSquare = document.createElement("span");
      colorSquare.className = "color-square";
      colorSquare.style.backgroundColor = color;
      colorSquare.title = `RGB: ${color}\nMSX: ${rgbToMsx(color)}`;
      if (index === 0) {
        colorSquare.classList.add("checkerboard");
        colorSquare.style.cursor = "default";
      } else {
        colorSquare.addEventListener("dblclick", () => {
          if (index > 0 && !transparentColors.includes(color) && transparentColors.length < 16) {
            const emptyInput = document.querySelector('.transparent-colors input[value=""]');
            if (emptyInput) {
              emptyInput.value = color;
            }
          }
        });
      }

      const labelSpan = document.createElement("span");
      labelSpan.textContent = index.toString(16).toUpperCase();
      const isDark = computeBrightness(color) < 128;
      labelSpan.style.color = isDark ? "#fff" : "#000";
      if (index === 0) {
        labelSpan.style.color = "#444";
      }
      colorSquare.appendChild(labelSpan);
      colorSquaresContainer.appendChild(colorSquare);
    });
    colorCell.style.height = "30px";
    colorCell.appendChild(colorSquaresContainer);
    colorRow.appendChild(colorCell);
    table.appendChild(colorRow);

    // Create the second row for the grid
    const gridRow = document.createElement("tr");
    const gridCell = document.createElement("td");
    gridCell.style.height = "100%";
    gridCell.style.overflowY = "auto"; // Enable vertical scrolling
    gridCell.style.display = "block"; // Ensure the cell takes the full height

    let nextId = getNextIDForType(document.getElementById("typeSelect").value);

    for (let row = 0; row < objectRows; row++) {
      for (let col = 0; col < objectColumns; col++) {
        const x = posX + col * (itemWidth + gapX);
        const y = posY + row * (itemHeight + gapY);

        const itemCanvas = document.createElement("canvas");
        itemCanvas.width = itemWidth;
        itemCanvas.height = itemHeight;
        const itemCtx = itemCanvas.getContext("2d");
        itemCtx.drawImage(canvas, x, y, itemWidth, itemHeight, 0, 0, itemWidth, itemHeight);
        const itemBase64 = itemCanvas.toDataURL();

        // Store the cropped image in the global array
        importPreviewImages.push({
          id: nextId,
          base64: itemBase64,
          description: `${document.getElementById("typeSelect").value.slice(0, -1)} #${nextId}`
        });

        const itemRow = document.createElement("div");
        itemRow.className = "imported-item-row";
        itemRow.style.display = "flex"; // Ensure all elements stay on the same row
        itemRow.style.alignItems = "center"; // Vertically center the elements
        itemRow.style.cursor = "pointer"; // Make the entire row clickable
        itemRow.addEventListener("click", () => {
          const previewImage = document.getElementById("previewImage");
          previewImage.src = itemBase64;
          highlightRow(itemRow);
        });

        const idCell = document.createElement("div");
        idCell.className = "imported-item-cell";
        idCell.style.fontWeight = "bold"; // Make ID bold
        idCell.style.width = "25px"; // Set ID width to 25px
        idCell.textContent = nextId++;

        const imageCell = document.createElement("div");
        imageCell.className = "imported-item-cell";
        const imgElement = document.createElement("img");
        imgElement.src = itemBase64;
        imgElement.style.width = "30px"; // Set image width to 30px
        imgElement.style.height = "30px"; // Set image height to 30px
        imgElement.style.imageRendering = "pixelated"; // Ensure the image is pixelated
        imageCell.appendChild(imgElement);

        const nameCell = document.createElement("div");
        nameCell.className = "imported-item-cell";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.maxLength = 255;
        nameInput.value = `${document.getElementById("typeSelect").value.slice(0, -1)} #${idCell.textContent}`;
        nameInput.title = nameInput.value; // Set initial tooltip
        nameInput.addEventListener("input", (e) => {
          nameInput.title = e.target.value; // Update tooltip on input change
          updateCroppedImageDescription(idCell.textContent, e.target.value);
        });
        nameCell.appendChild(nameInput);

        const removeCell = document.createElement("div");
        removeCell.className = "imported-item-cell";
        const removeButton = document.createElement("button");
        removeButton.textContent = "X";
        removeButton.title = "Remove";
        removeButton.addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent row click event
          removePreviewRow(itemRow, idCell.textContent);
        });
        removeCell.appendChild(removeButton);

        itemRow.appendChild(idCell);
        itemRow.appendChild(imageCell);
        itemRow.appendChild(nameCell);
        itemRow.appendChild(removeCell);

        gridCell.appendChild(itemRow);
      }
    }
    gridRow.style.height = "250px";
    gridRow.appendChild(gridCell);
    table.appendChild(gridRow);

    // Create the third row for the image preview
    const previewRow = document.createElement("tr");
    const previewCell = document.createElement("td");
    previewCell.style.height = "100%";
    previewCell.style.overflow = "auto"; // Enable scrolling
    previewCell.style.display = "block"; // Ensure the cell takes the full height

    const previewContainer = document.createElement("div");
    previewContainer.className = "preview-container";

    const previewImage = document.createElement("img");
    previewImage.id = "previewImage";
    previewImage.className = "preview-image";
    previewImage.style.width = "100%"; // Ensure the image fits the container
    previewImage.style.height = "160px";
    previewImage.style.backgroundColor = "#ffffff"; // Default background color
    previewImage.style.cursor = "grab"; // Change cursor to indicate draggable
    previewImage.style.imageRendering = "pixelated"; // Ensure the image is pixelated
    previewImage.addEventListener("wheel", (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        let scale = parseFloat(previewImage.style.transform.replace("scale(", "").replace(")", "")) || 1;
        scale += e.deltaY < 0 ? 0.1 : -0.1;
        scale = Math.max(0.1, scale);
        previewImage.style.transform = `scale(${scale})`;
      }
    });

    let isDragging = false;
    let startX, startY, scrollLeft, scrollTop;

    previewImage.addEventListener("mousedown", (e) => {
      isDragging = true;
      startX = e.pageX - previewCell.offsetLeft;
      startY = e.pageY - previewCell.offsetTop;
      scrollLeft = previewCell.scrollLeft;
      scrollTop = previewCell.scrollTop;
      previewImage.style.cursor = "grabbing";
    });

    previewImage.addEventListener("mouseleave", () => {
      isDragging = false;
      previewImage.style.cursor = "grab";
    });

    previewImage.addEventListener("mouseup", () => {
      isDragging = false;
      previewImage.style.cursor = "grab";
    });

    previewImage.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const x = e.pageX - previewCell.offsetLeft;
      const y = e.pageY - previewCell.offsetTop;
      const walkX = (x - startX) * 1; // Adjust the multiplier for faster/slower scrolling
      const walkY = (y - startY) * 1; // Adjust the multiplier for faster/slower scrolling
      previewCell.scrollLeft = scrollLeft - walkX;
      previewCell.scrollTop = scrollTop - walkY;
    });

    const backgroundColorButton = document.createElement("button");
    backgroundColorButton.className = "background-color-button";
    backgroundColorButton.textContent = "Background color";
    backgroundColorButton.addEventListener("click", () => {
      
      openColorPickerDialog(previewImage.style.backgroundColor, (newColor) => {
        previewImage.style.backgroundColor = newColor;
      });
    });

    previewContainer.appendChild(previewImage);
    previewContainer.appendChild(backgroundColorButton);
    previewCell.style.height = "200px";
    previewCell.style.paddingTop = "25px";
    previewCell.appendChild(previewContainer);
    previewRow.appendChild(previewCell);
    table.appendChild(previewRow);

    importedItemsPanel.appendChild(table);

    // Show the import button
    document.getElementById("importImport").style.display = "inline-block";

    // Focus on the first row and display its image in the preview
    const firstRow = document.querySelector(".imported-item-row");
    if (firstRow) {
      highlightRow(firstRow);
      const firstImage = firstRow.querySelector("img");
      if (firstImage) {
        previewImage.src = firstImage.src;
      }
    }
  };
  
  img.src = croppedImage;
}

function removePreviewRow(row, id) {
  const index = importPreviewImages.findIndex(img => img.id === id);
  if (index !== -1) {
    importPreviewImages.splice(index, 1);
    row.remove();
    const rows = document.querySelectorAll(".imported-item-row");
    if (rows.length > 0) {
      const newFocusRow = rows[Math.max(0, index - 1)];
      highlightRow(newFocusRow);
    } else {
      // Hide the import button if no rows are left
      document.getElementById("importImport").style.display = "none";
    }
  }
}

function getClosestColor(pixelColor, hexPalette) {
  let minDistance = Infinity;
  let closestColor = [255, 255, 255];
  hexPalette.forEach(hex => {
    const color = hexToRgb(hex);
    const distance = colorDistance(pixelColor, color);
    if (distance < minDistance) {
      minDistance = distance;
      closestColor = color;
    }
  });

  return closestColor;
}

//function hexToRgb(hex) {
//  const bigint = parseInt(hex.slice(1), 16);
//  const r = (bigint >> 16) & 255;
//  const g = (bigint >> 8) & 255;
//  const b = bigint & 255;
//  return [r, g, b];
//}

function colorDistance(color1, color2) {
  const rDiff = color1[0] - color2[0];
  const gDiff = color1[1] - color2[1];
  const bDiff = color1[2] - color2[2];
  return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
}

/* ======================================================================================
   getRequiredFieldsForType
   ====================================================================================== */
function getRequiredFieldsForType(type) {
  switch (type) {
    case "Sprites":
      return ["Description", "Size", "ChildObjectID"];
    case "Tiles":
      return ["Description", "Size", "ChildObjectID"];
    case "Maps":
      return ["Description", "Size", "ChildObjectID"];
    case "Fonts":
      return ["Description", "Size", "FontSpaces", "FirstFontChar", "LastFontChar", "ChildObjectID"];
    case "Palettes":
      return ["Description", "Values"];
    case "Images":
      return ["Description", "Size", "ChildObjectID"];
    case "Animations":
      return ["Description", "ChildObjectID"];
    default:
      return [];
  }
}
function getFieldNames(type,fieldName) {
  switch (type) {
    case "Sprites":

        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
        }
    case "Tiles":
       switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
        }
    case "Maps":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Tile";
        }
    case "Fonts":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "FontSpaces":
                return "Spaces (H/V)";
            case "FirstFontChar":
                return "First char";
            case "LastFontChar":
                return "Last char";
            case "ChildObjectID":
                return "PalettTilee";
        }
    case "Palettes":
        switch(fieldName){
            case "Description":
                return "Description";
            case "Values":
                return "Colors";
        }
    case "Images":
    switch(fieldName){
            case "Description":
                return "Description";
            case "Size":
                return "Size";
            case "ChildObjectID":
                return "Palette";
        }
    case "Animations":
    switch(fieldName){
            case "Description":
                return "Description";
            case "ChildObjectID":
                return "Sprite/Tile";
        }   
    default:
      return [];
  }
}

function scrollToRecord(record) {
  const rows = document.querySelectorAll("#dataGrid tbody tr");
  rows.forEach(row => {
    const cells = row.querySelectorAll("td");
    if (cells.length > 0 && cells[0].textContent == record.ID) {
      row.scrollIntoView({ behavior: "smooth", block: "center" });
      row.classList.add("highlight");
      setTimeout(() => row.classList.remove("highlight"), 2000);
    }
  });
}

function applyFilters(type, subtype) {
  document.getElementById("typeSelect").value = type;
  updateSubtypeCombo();
  if (subtype) {
    document.getElementById("subtypeSelect").value = subtype;
  }
}

function openImportDialog(record) {
  const overlay = document.getElementById("importDialogOverlay");
  const paletteSelect = document.getElementById("paletteSelect");
  const header = document.getElementById("importDialogHeader");

  // Clear all fields
  document.getElementById("objectColumns").value = 1;
  document.getElementById("objectRows").value = 1;
  document.getElementById("gapX").value = 0;
  document.getElementById("gapY").value = 0;
  document.getElementById("posX").value = 0;
  document.getElementById("posY").value = 0;
  document.getElementById("minColorsDistance").value = 1;
  document.getElementById("importFile").value = "";
  document.getElementById("selectedImage").src = "";
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";

  // Remove color squares and grid if they exist
  const colorSquaresContainer = document.querySelector(".color-squares-container");
  if (colorSquaresContainer) {
    colorSquaresContainer.remove();
  }
  const importedItemsPanel = document.getElementById("importedItemsPanel");
  importedItemsPanel.innerHTML = "";

  // Set header text
  const recordType = record.Type.slice(0, -1); // Remove last character
  header.textContent = `${recordType} ${record.Description} (${record.Size})`;

  paletteSelect.innerHTML = '<option value="areaonlycolors">Create a new palette (only selected area colors)</option><option value="allimagecolors">Create a new palette (all image colors)</option>';
  getPaletteOptions().forEach(opt => {
    let option = document.createElement("option");
    option.value = opt.value;
    option.textContent = opt.label;
    paletteSelect.appendChild(option);
  });

  // Check the number of items in the record
  if (record.Values && record.Values.length > 0) {
    // Set the palette to the record's palette and disable the combo
    paletteSelect.value = record.ChildObjectID;
    paletteSelect.disabled = true;
  } else {
    // Enable the combo for palette selection
    paletteSelect.disabled = false;
  }

  overlay.style.display = "flex";
  overlay.dataset.recordId = record.ID; // Store the record ID in the overlay for later use
}

document.getElementById("importFile").addEventListener("change", () => {
  const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }
  const record = dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10));
  const importFile = document.getElementById("importFile").files[0];
  const paletteOption = document.getElementById("paletteSelect").value;

  // Hide import button and clear previous preview
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";
  document.getElementById("selectedImage").src = "";
  const importedItemsPanel = document.getElementById("importedItemsPanel");
  importedItemsPanel.innerHTML = "";

  if (!importFile || (importFile.type !== "image/png" && importFile.type !== "image/bmp")) {
    openValidationDialog("Please select a valid PNG or BMP file.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function(event) {
    const base64Image = event.target.result;
    if (!isValidImage(base64Image)) {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
      return;
    }

    const img = new Image();
    img.onload = function() {
      const imgWidth = img.width;
      const imgHeight = img.height;
      const [recordWidth, recordHeight] = record.Size.split("x").map(Number);
      const totalWidth = (recordWidth * importSpecs.objectColumns) + parseInt(importSpecs.posX, 10);
      const totalHeight = (recordHeight * importSpecs.objectRows) + parseInt(importSpecs.posY, 10);

      if (imgWidth < totalWidth || imgHeight < totalHeight) {
        openValidationDialog("Total width or height set for extracting items is incompatible with the image.");
        document.getElementById("selectedImage").src = "";
        document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
        return;
      }

      // Display the image in the selected-image panel
      const selectedImage = document.getElementById("selectedImage");
      selectedImage.src = base64Image;

      // Proceed with preview
      document.getElementById("importedItemsPanel").style.display = "grid"; // Show the preview panel
      document.getElementById("importPreview").style.display = "inline-block"; // Show the Preview button
      document.getElementById("importImport").style.display = "none"; // Hide the Import button initially
      vscode.postMessage({
        command: 'validateImportSpecs',
        data: importSpecs,
        record: record,
        paletteOption: paletteOption
      });
    };
    img.onerror = function() {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    };
    img.src = base64Image;
  };
  reader.readAsDataURL(importFile);
});

document.getElementById("importPreview").addEventListener("click", () => {
 
  const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
  const currentType = document.getElementById("typeSelect").value;
  let currentSubtype = "";
  if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
    currentSubtype = document.getElementById("subtypeSelect").value;
  }
  const record = dataStore.find(r =>r.Type===currentType && r.Subtype===currentSubtype && r.ID === parseInt(recordId, 10));
  console.log("RECORD ID",document.getElementById("importDialogOverlay").dataset);
  const importFile = document.getElementById("importFile").files[0];
  const paletteOption = document.getElementById("paletteSelect").value;
  const minColorsDistance = parseInt(document.getElementById("minColorsDistance").value, 10);

  if (!importFile || (importFile.type !== "image/png" && importFile.type !== "image/bmp")) {
    openValidationDialog("Please select a valid PNG or BMP file.");
    return;
  }

  const objectColumns = parseInt(document.getElementById("objectColumns").value, 10);
  const objectRows = parseInt(document.getElementById("objectRows").value, 10);
  const gapX = parseInt(document.getElementById("gapX").value, 10);
  const gapY = parseInt(document.getElementById("gapY").value, 10);
  const posX = parseInt(document.getElementById("posX").value, 10);
  const posY = parseInt(document.getElementById("posY").value, 10);

  // Validate number of columns and rows
  if (objectColumns < 1 || objectRows < 1) {
    openValidationDialog("Impostare il numero di righe e colonne di items da importare");
    document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    return;
  }

  // Validate color distance if creating a new palette
  if ((paletteOption === "areaonlycolors" || paletteOption === "allimagecolors") && (minColorsDistance < 1 || minColorsDistance > 255)) {
    openValidationDialog("Invalid color distance");
    document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    return;
  }

  const [recordWidth, recordHeight] = record.Size.split("x").map(Number);
  console.log("RECORD WIDTH",recordWidth);
  console.log("RECORD HEIGHT",recordHeight);
 console.log("RECORD",record);
  const totalWidth = posX + (recordWidth * objectColumns) + (gapX * (objectColumns - 1));
  const totalHeight = posY + (recordHeight * objectRows) + (gapY * (objectRows - 1));

  const reader = new FileReader();
  reader.onload = function(event) {

    const base64Image = event.target.result;
    if (!isValidImage(base64Image)) {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
      return;
    }

    const img = new Image();
    img.onload = function() {
  
      const imgWidth = img.width;
      const imgHeight = img.height;

      // Validate image dimensions
      if (imgWidth < totalWidth || imgHeight < totalHeight) {
        openValidationDialog("Dimensione immagine incompatibile con i parametri specificati");
        document.getElementById("selectedImage").src = "";
        document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
        return;
      }

      // Create a canvas to draw the cropped image
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = totalWidth;
      canvas.height = totalHeight;
      ctx.drawImage(img, posX, posY, totalWidth, totalHeight, 0, 0, totalWidth, totalHeight);
      const croppedImage = canvas.toDataURL();
      //console.log("CANVAS",canvas);
      //console.log("CROPPED IMAGE",croppedImage);
      // Get transparent colors
      const transparentColors = Array.from(document.querySelectorAll('.transparent-colors input'))
        .map(input => input.value.toUpperCase())
        .filter(color => color);

      // Define hexPalette
      let hexPalette = [];

      // If a new palette needs to be created
      if (paletteOption === "areaonlycolors" || paletteOption === "allimagecolors") {
        //console.log("IMAGE TO USE",paletteOption,croppedImage,base64Image);
        const imageToUse = paletteOption === "areaonlycolors" ? croppedImage : base64Image;
        //console.log("IMAGE TO USE",imageToUse); 
        croppedImportImages=croppedImage;
        noCroppedImportImages=imageToUse;

        processImageForTransparency(croppedImportImages, (processedImage) => {
          croppedImportImages=processedImage;

          processImageForTransparency(noCroppedImportImages, (processedImage) => {
            noCroppedImportImages=processedImage;
            getDominantColorsFromDataUrl(noCroppedImportImages, minColorsDistance, croppedImportImages, transparentColors, [recordWidth, recordHeight]);
        });
        });









        
        //getDominantColorsFromDataUrl(imageToUse, minColorsDistance, croppedImage, transparentColors, [recordWidth, recordHeight]);
      } else {
        const selectedPalette = dataStore.find(p => p.Type === "Palettes" && p.ID.toString() === paletteOption);
        if (selectedPalette) {
          hexPalette = selectedPalette.Values.map(c => c.color.toUpperCase());
          importItemsFromImage(hexPalette, croppedImage, transparentColors, [recordWidth, recordHeight]);
        }
      }
     
      // Show the import button after successful preview
      document.getElementById("importImport").style.display = "inline-block";
    };







    img.onerror = function() {
      openValidationDialog("Invalid image format. Please select a valid PNG or BMP file.");
      document.getElementById("selectedImage").src = "";
      document.getElementById("importPreview").style.display = "inline-block"; // Ensure the Preview button remains visible
    };
    img.src = base64Image;
  };
  reader.readAsDataURL(importFile);
});

document.getElementById("importClose").addEventListener("click", () => {
  document.getElementById("importDialogOverlay").style.display = "none";
  document.getElementById("selectedImage").src = "";
  document.getElementById("importPreview").style.display = "none";
  document.getElementById("importImport").style.display = "none";
});



function processImageForTransparency(imageSrc, callback) {
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Get transparent colors from the grid
    const transparentColors = Array.from(document.querySelectorAll('.transparent-colors input'))
      .map(input => input.value.toUpperCase())
      .filter(color => color);

    // Replace transparent pixels with #000000 at 100% transparency
    for (let i = 0; i < data.length; i += 4) {
      if (data[i + 3] < 255) {
        data[i] = 0;
        data[i + 1] = 0;
        data[i + 2] = 0;
        data[i + 3] = 0;
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Replace opaque #000000 pixels with #010101
    for (let i = 0; i < data.length; i += 4) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0 && data[i + 3] === 255) {
        data[i] = 1;
        data[i + 1] = 1;
        data[i + 2] = 1;
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Replace colors present in transparentColors with #000000 transparent
    for (let i = 0; i < data.length; i += 4) {
      const pixelColor = `#${((1 << 24) + (data[i] << 16) + (data[i + 1] << 8) + data[i + 2]).toString(16).slice(1).toUpperCase()}`;
      if (transparentColors.includes(pixelColor)) {
        data[i] = 0;
        data[i + 1] = 0;
        data[i + 2] = 0;
        data[i + 3] = 0;
      }
    }
    ctx.putImageData(imageData, 0, 0);

    const processedImage = canvas.toDataURL();
    callback(processedImage);
  };
  img.src = imageSrc;
}

function openValidationDialog(message) {
  const overlay = document.getElementById("validationOverlay");
  const msg = document.getElementById("validationMessage");
  msg.textContent = message;
  overlay.style.display = "flex";
}

document.getElementById("validationOk").addEventListener("click", () => {
  document.getElementById("validationOverlay").style.display = "none";
});

function isValidImage(base64Image) {
  const pngHeader = "data:image/png;base64,";
  const bmpHeader = "data:image/bmp;base64,";
  return base64Image.startsWith(pngHeader) || base64Image.startsWith(bmpHeader);
}

document.querySelectorAll('.tab-button').forEach(button => {
  button.addEventListener('click', () => {
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    button.classList.add('active');
    document.getElementById(button.dataset.tab).classList.add('active');
  });
});



document.querySelectorAll('.transparent-colors input').forEach(input => {
  input.addEventListener('blur', () => {
    if (!/^#[0-9A-F]{6}$/i.test(input.value)) {
      input.value = '';
    }
  });
});

document.getElementById("selectedImagePanel").addEventListener("wheel", (e) => {
  if (e.ctrlKey) {
    e.preventDefault();
    const img = document.getElementById("selectedImage");
    let scale = parseFloat(img.style.transform.replace("scale(", "").replace(")", "")) || 1;
    scale += e.deltaY < 0 ? 0.1 : -0.1;
    scale = Math.max(0.1, scale);
    img.style.transform = `scale(${scale})`;
  }
});

let isDragging = false;
let startX, startY, scrollLeft, scrollTop;

const selectedImagePanel = document.getElementById("selectedImagePanel");
const selectedImage = document.getElementById("selectedImage");

selectedImagePanel.addEventListener("mousedown", (e) => {
  isDragging = true;
  startX = e.pageX - selectedImagePanel.offsetLeft;
  startY = e.pageY - selectedImagePanel.offsetTop;
  scrollLeft = selectedImagePanel.scrollLeft;
  scrollTop = selectedImagePanel.scrollTop;
  selectedImage.style.cursor = "grabbing";
});

selectedImagePanel.addEventListener("mouseleave", () => {
  isDragging = false;
  selectedImage.style.cursor = "grab";
});

selectedImagePanel.addEventListener("mouseup", () => {
  isDragging = false;
  selectedImage.style.cursor = "grab";
});

selectedImagePanel.addEventListener("mousemove", (e) => {
  if (!isDragging) return;
  e.preventDefault();
  const x = e.pageX - selectedImagePanel.offsetLeft;
  const y = e.pageY - selectedImagePanel.offsetTop;
  const walkX = (x - startX) * 1; // Adjust the multiplier for faster/slower scrolling
  const walkY = (y - startY) * 1; // Adjust the multiplier for faster/slower scrolling
  selectedImagePanel.scrollLeft = scrollLeft - walkX;
  selectedImagePanel.scrollTop = scrollTop - walkY;
});

document.getElementById("importImport").addEventListener("click", () => {
  openConfirmDialog(() => {
    const recordId = document.getElementById("importDialogOverlay").dataset.recordId;
    const currentType = document.getElementById("typeSelect").value;
    let currentSubtype = "";
    if (!document.getElementById("subtypeSelect").classList.contains("hidden")) {
      currentSubtype = document.getElementById("subtypeSelect").value;
    }
    const record = dataStore.find(r => r.Type === currentType && r.Subtype === currentSubtype && r.ID === parseInt(recordId, 10));
    const type = document.getElementById("typeSelect").value;
    const newItems = [];

    importPreviewImages.forEach((image, index) => {
      const item = {
        ID: index + 1,
        Name: image.description,
        Order: getNextOrder(record.Values),
        Matrices: [{
          ID: 1,
          Values: [],
          OrOptions: Array.from({ length: parseInt(record.Size.split("x")[1], 10) }, (_, rowIndex) => ({
            Row: rowIndex,
            Status: false
          }))
        }]
      };

      const img = new Image();
      img.src = image.base64;
      img.onload = () => {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        console.log("PALETTE",importPalette);
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            const pixelColor = [data[i], data[i + 1], data[i + 2]];
            const colorIndex = importPalette.findIndex(c => {
              const [r, g, b] = hexToRgb(c);
              return r === pixelColor[0] && g === pixelColor[1] && b === pixelColor[2];
            });
            if (colorIndex === -1) {
              console.log("PIXEL COLOR NOT FOUND", pixelColor); 
            }
            item.Matrices[0].Values.push({
              PosX: x,
              PosY: y,
              Value: colorIndex.toString(16).toUpperCase()
            });
          }
        }

        newItems.push(item);

        if (newItems.length === importPreviewImages.length) {
          if (importPaletteID === -1) {
            // Ensure the new palette has 16 colors
            const newPaletteColors = importPalette.map((color, index) => ({
              id: index.toString(16).toUpperCase(),
              color: color
            }));
            newPaletteColors[0] = { id: "0", color: "#000000" };
            while (newPaletteColors.length < 16) {
              newPaletteColors.push({ id: newPaletteColors.length.toString(16).toUpperCase(), color: "#FFFFFF" });
            }

            const newPalette = {
              ID: getNextIDForType("Palettes"),
              Type: "Palettes",
              Description: `Palette for ${type} ${record.Description}`,
              Subtype: "",
              Values: newPaletteColors
            };
            dataStore.push(newPalette);
            record.ChildObjectID = newPalette.ID;
          } else {
            record.ChildObjectID = importPaletteID;
          }

          record.Values = newItems;
          saveDataStore();
          document.getElementById("importDialogOverlay").style.display = "none";
          updateGrid();
        }
      };
    });
  });
});

function getNextOrder(values) {
  if (!values || values.length === 0) return 1;
  return Math.max(...values.map(v => v.Order)) + 1;
}

function openConfirmDialog(onConfirm) {
  const overlay = document.getElementById("confirmOverlay");
  const msg = document.getElementById("confirmDialog").querySelector("p");
  const okBtn = document.getElementById("confirmOk");
  const cancelBtn = document.getElementById("confirmCancel");

  msg.textContent = "Are you sure to import these items?";
  overlay.style.display = "flex";
  overlay.style.zIndex = "9999"; // Ensure the z-index is the same as the color picker dialog

  const onOk = () => {
    closeConfirm();
    onConfirm();
  };
  const onCancel = () => {
    closeConfirm();
  };
  const closeConfirm = () => {
    overlay.style.display = "none";
    okBtn.removeEventListener("click", onOk);
    cancelBtn.removeEventListener("click", onCancel);
  };

  okBtn.addEventListener("click", onOk);
  cancelBtn.addEventListener("click", onCancel);
}

</script>
</body>
</html>
