/**
 * MSXDev Tool Extension for VS Code
 * Copyright (C) 2025  Fausto Pracek
 *
 * This file is part of MSXDev Tool Extension for VS Code.
 *
 * MSXDev Tool Extension for VS Code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MSXDev Tool Extension for VS Code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MSXDev Tool Extension for VS Code. If not, see <https://www.gnu.org/licenses/>.
 */





function CreateCode(codeGeneratorItems, codeGeneratorScreenMode, codGeneratorMachine) {
  console.log(codeGeneratorItems);
  let codeString = "// Generated by MSXDev Tool Extension for VS Code\n\n";
  codeString += '// =======\n';
  codeString += '// INCLUDE\n';
  codeString += '// =======\n';
  codeString += '#include "msxgl.h"\n';
  codeString += '#include "bios.h"\n';

  if (codeGeneratorItems.some(item => item.Type === 'Tiles')) {
    codeString += '#include "vdp.h"\n';
  }
  if (codeGeneratorItems.some(item => item.Type === 'Fonts')) {
    codeString += '#include "print.h"\n';
  }

  codeString += '#include "tile.h"\n';
  codeString += '\n';

  // Add arrays for each item using existing export functions
  codeGeneratorItems.forEach(item => {
    switch (item.Type) {
      case 'Palettes':
        codeString += exportPalette(item, 'C (MSXgl)') + '\n';
        break;
      case 'Tiles':
        codeString += exportTiles(item, 'C (MSXgl)') + '\n';
        break;
      case 'Fonts':
        codeString += exportFonts(item, 'C (MSXgl)') + '\n';
        break;
      case 'Sprites':
        codeString += exportSprites(item, 'C (MSXgl)') + '\n';
        break;
      case 'Maps':
        codeString += exportMaps(item, 'C (MSXgl)') + '\n';
        break;
      case 'Images':
        codeString += exportImages(item, 'C (MSXgl)') + '\n';
        break;
      default:
        throw new Error('Unsupported item type');
    }
  });

  codeString += '// ====\n';
  codeString += '// MAIN\n';
  codeString += '// ====\n';
  codeString += 'main()\n{\n';

  // Add VDP_SetMode based on codeGeneratorScreenMode
  switch (codeGeneratorScreenMode.toString()) {
    case '0':
      if (codGeneratorMachine == 'MSX1') {
        codeString += '\tVDP_SetMode(VDP_MODE_SCREEN0_W40);\n';
        codeString += '\tVDP_SetLayoutTable(VDP_T1_ADDR_NT);\n';
      } else {
        codeString += '\tVDP_SetMode(VDP_MODE_SCREEN0);\n';
        codeString += '\tVDP_SetLayoutTable(VDP_T2_ADDR_NT);\n';
      }
      break;
    case '1':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN1);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G1_ADDR_NT);\n';
      break;
    case '2':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN2);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G2_ADDR_NT);\n';
      break;
    case '3':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN3);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_MC_ADDR_NT);\n';
      break;
    case '4':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN4);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G3_ADDR_NT);\n';
      break;
    case '5':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN5);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G4_ADDR_NT);\n';
      break;
    case '6':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN6);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G5_ADDR_NT);\n';
      break;
    case '7':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN7);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G6_ADDR_NT);\n';
      break;
    case '8':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN8);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '10':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN10);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '11':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN11);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '12':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN12);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    default:
      console.log(codeGeneratorScreenMode);
  }

  codeString += '\n';
  
  // Add Palette functions for each Tiles record
  codeGeneratorItems.forEach(item => {
    if (item.Type === 'Palettes') {
      const palettesData = `Tile_${item.ID}`;
      codeString += `\tVDP_SetPalette(${palettesData});\n`;
    }
  });
  codeString += '\n';

  // Add Print_SetBitmapFont for the first Fonts record
  const firstSprite = codeGeneratorItems.find(item => item.Type === 'Sprites' && item.subtype==="Type 1" && (item.Size === '8x8' || item.Size === '16x16'));
  if (firstSprite) {
    const spriteData = `Sprite_${firstSprite.ID}`;
    const spriteCount = firstSprite.Size==="8x8"?firstSprite.Values.length:firstSprite.Values.length*4;
    codeString += `\tVDP_LoadSpritePattern(${spriteData},0,${spriteCount});\n`;
  }

  // Add Print_SetBitmapFont for the first Fonts record
  const firstFont = codeGeneratorItems.find(item => item.Type === 'Fonts');
  if (firstFont) {
    const fontName = `FontSet_${firstFont.ID}`;

    switch (firstFont.Values[0].exportType) {
      case 'Text':
        codeString += `\tPrint_SetTextFont(${fontName},0); // This function requires PRINT_USE_TEXT compile option to be set to TRUE\n`;
        break;
      case 'Sprite':
        codeString += `\tPrint_SetSpriteFont((${fontName}, 0, 0); // This function requires PRINT_USE_SPRITE compile option to be set to TRUE\n`;
        break;
      case 'VRAM':
        codeString += `\tPrint_SetVRAMFont(${fontName},212,RGB8(4,4,2)); // This function requires PRINT_USE_VRAM compile option to be set to TRUE\n`;
        break;
      case 'Bitmap':
        codeString += `\tPrint_SetBitmapFont(${fontName}); // This function requires PRINT_USE_BITMAP compile option to be set to TRUE.\n`;
        break;
      case 'Bitmap trans':
        codeString += `\tPrint_SetBitmapFont(${fontName}); // This function requires PRINT_USE_BITMAP compile option to be set to TRUE.\n`;
        codeString += `\tPrint_SetMode(PRINT_MODE_BITMAP_TRANS)\n`;
        break
    }
    
    
    codeString += `\tPrint_SetBitmapFont(${fontName});\n`;
  }

  // Add Tile functions for the first Tiles record
  const firstTile = codeGeneratorItems.find(item => item.Type === 'Tiles');
  if (firstTile) {
    const tilesData = `Tile_${firstTile.ID}`;
    codeString += `\tTile_SelectBank(0);\n`;
    codeString += `\tTile_SetDrawPage(0);\n`;
    codeString += `\tTile_LoadBank(0, ${tilesData}, ${firstTile.Values.length.toString()});\n`;
  }

  codeString += '}';

  return codeString;
}
function htmlToMSXColor(hexColor) {

  // Removes the initial "#", if present
  const cleanHex = hexColor.replace(/^#/, "");



  // Extracts the R, G, and B components in decimal (0-255)
  const rDec = parseInt(cleanHex.slice(0, 2), 16);
  const gDec = parseInt(cleanHex.slice(2, 4), 16);
  const bDec = parseInt(cleanHex.slice(4, 6), 16);

  // Converts each channel from [0..255] to [0..15].
  // Using division by 17 and rounding: 255/17 = 15
  const r4 = Math.round(rDec / 17);
  const g4 = Math.round(gDec / 17);
  const b4 = Math.round(bDec / 17);


  const byte1 = (r4 << 4) | g4;

  const byte2 = b4; 


  const hexByte1 = byte1.toString(16).toUpperCase().padStart(2, '0');
  const hexByte2 = byte2.toString(16).toUpperCase().padStart(2, '0');

  return [hexByte1, hexByte2];
}
function rgbToMsx(hexColor) {
  // Removes the initial "#", if present
  const cleanHex = hexColor.replace(/^#/, "");

  // Checks that the string is 6 hexadecimal characters long
  if (cleanHex.length !== 6) {
    throw new Error("Invalid color format: must be #rrggbb");
  }

  // Extracts the R, G, and B components in decimal (0-255)
  const rDec = parseInt(cleanHex.slice(0, 2), 16);
  const gDec = parseInt(cleanHex.slice(2, 4), 16);
  const bDec = parseInt(cleanHex.slice(4, 6), 16);

  // Converts each channel from [0..255] to [0..15].
  // Using division by 17 and rounding: 255/17 = 15
  const r4 = Math.round(rDec / 17);
  const g4 = Math.round(gDec / 17);
  const b4 = Math.round(bDec / 17);

  // Returns the string with the channel names
  return `Red=${r4.toString(16).toUpperCase()}, Green=${g4.toString(16).toUpperCase()}, Blue=${b4.toString(16).toUpperCase()}`;
}
function parseImageData(inputString) {
  // Suddividi in linee
  const lines = inputString.split(/\r?\n/).map(line => line.trim()).filter(Boolean);


  // Trova indice ITEM e PALETTE
  const itemIndex = lines.findIndex(line => line.toUpperCase() === "ITEM");
  const paletteIndex = lines.findIndex(line => line.toUpperCase() === "PALETTE");


  if (itemIndex === -1 || paletteIndex === -1) {
    throw new Error("Stringa non valida: impossibile trovare i tag ITEM o PALETTE.");
  }


  // Estrai le linee relative ai bytes dell'immagine (tra ITEM e PALETTE)
  const itemLines = lines.slice(itemIndex + 1, paletteIndex);


  // Estrai le linee (in teoria una sola) con i colori della palette
  // Nel tuo esempio c'è una sola riga dopo "PALETTE", ma potresti adattare
  // se la palette fosse su più righe.
  const paletteLines = lines.slice(paletteIndex + 1);


  // 1) Parsiamo la palette (16 colori).
  //    Ogni colore è tipo #RRGGBB e #000000 corrisponde a trasparente.
  let paletteString = paletteLines.join(""); // unisci eventuali linee
  // Rimuovi eventuali virgolette finali, punti e virgola superflui, ecc.
  paletteString = paletteString.replace(/[";]/g, " ").trim(); // toglie " e ; e sostituisce con spazio


  const paletteParts = paletteString.split(/\s+/).filter(Boolean);
  // A questo punto dovremmo avere un array di 16 stringhe "#RRGGBB"
  if (paletteParts.length !== 16) {
    throw new Error("La palette deve avere esattamente 16 colori.");
  }


  // Converto ogni colore in un oggetto {r, g, b, a}
  const palette = paletteParts.map(col => {
    // Esempio col: "#000000" => 0,0,0
    // #000000 è trasparente, quindi a=0, altrimenti a=255
    const r = parseInt(col.slice(1, 3), 16);
    const g = parseInt(col.slice(3, 5), 16);
    const b = parseInt(col.slice(5, 7), 16);


    // Se è #000000 => alpha=0 (trasparente), altrimenti 255
    const alpha = (r === 0 && g === 0 && b === 0) ? 0 : 255;


    return { r, g, b, a: alpha };
  });


  // 2) Parsiamo i bytes dopo ITEM (itemLines).
  // Ogni riga rappresenta una riga di pixel.
  // Ogni “0x??” rappresenta un byte => 2 pixel orizzontali (nibble alto, nibble basso).
  //
  // Quindi la larghezza in pixel = numero di bytes per riga * 2
  // L’altezza in pixel = numero di righe


  // Esempio:
  //   0x11;0x11;0x11;0x11;
  //   => 4 bytes => 4 * 2 = 8 pixel di larghezza per riga


  // Array 2D di righe di pixel (ma poi ci serve 1D per l'ImageData).
  const rows = itemLines.map(line => {
    // Rimuovo eventuali ; e spazi superflui
    const clean = line.replace(/;/g, " ").trim();
    const parts = clean.split(/\s+/).filter(Boolean); // [ "0x11", "0x11", "0x11", "0x11" ]


    // Converto ciascun "0x.." in un numero
    const bytes = parts.map(p => parseInt(p, 16));


    // Ogni byte => 2 pixel => decodifico
    const pixelsInRow = [];
    for (let b of bytes) {
      // nibble alto = b >> 4
      // nibble basso = b & 0x0F
      const highNibble = (b >> 4) & 0x0F; 
      const lowNibble  = b & 0x0F;


      // Ogni nibble è un indice nella palette
      pixelsInRow.push(highNibble, lowNibble);
    }
    return pixelsInRow; // array di indici di palette (lunghezza = bytes.length * 2)
  });


  // Dimensioni immagine
  const height = rows.length;
  const width = rows[0]?.length || 0;
  if (!width || !height) {
    console.log("Nessun dato immagine trovato o immagine non valida.");
    return;
  }


  // 3) Costruiamo un canvas con le dimensioni trovate
  //    e creiamo l'ImageData da riempire.
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");


  // Creiamo un ImageData
  const imageData = ctx.createImageData(width, height);
  const data = imageData.data; // Uint8ClampedArray


  // Riempio i byte RGBA
  // riga => y
  // colonna => x
  // data index = (y * width + x) * 4
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const paletteIndex = rows[y][x];
      const { r, g, b, a } = palette[paletteIndex];
      const idx = (y * width + x) * 4;
      data[idx + 0] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;
      data[idx + 3] = a;
    }
  }


  // Disegno l’ImageData sul canvas
  ctx.putImageData(imageData, 0, 0);


  // 4) Estraggo la stringa base64 in formato PNG
  const base64Png = canvas.toDataURL("image/png");


  return base64Png; 
}

async function getImageArray(wasmPath,base64Image) {
  console.log("OK, base64Image");
  console.log("WASM_PATH", wasmPath);
  // Carica il modulo WebAssembly
  const wasmModule = await WebAssembly.instantiateStreaming(wasmPath);
  
  // Ottieni la funzione GetArrayFromImage dal modulo WebAssembly
  const { GetArrayFromImage } = wasmModule.instance.exports;

  // Definisci le variabili per i parametri obbligatori
  let exitMessage = "";
  let exportedData = "";
  const dataTableName = "PROVA";
  const sizeX = 8;
  const sizeY = 8;
  const numBlockX = 1;
  const numBlockY = 1;

  // Chiama la funzione GetArrayFromImage
  const result = GetArrayFromImage(base64Image, exitMessage, exportedData, dataTableName, sizeX, sizeY, numBlockX, numBlockY);

  if (!result) {
    console.error("Errore:", exitMessage);
  } else {
    console.log("Dati esportati:", exportedData);
  }
}

function getImageFromObject(id, objectRecord, paletteRecord, onlyMatrix = -1) {
  // Deserializza l'attributo Values di paletteRecord
  const paletteValues = paletteRecord.Values;
  
  // Crea un array di tutti gli ID del paletteRecord con colore #000000
  const transparentColorsID = paletteValues.filter(color => color.color === "#000000").map(color => color.id);
  
  // Crea un array di tutti gli ID del paletteRecord
  const paletteColors = paletteValues.map(color => color.color);
  
  // Deserializza l'attributo Values di objectRecord
  const objectInfo = objectRecord.Values;
  
  // Individua il pattern in Values di objectInfo con ID uguale a quello ricevuto come parametro
  const pattern = objectInfo.find(o => o.ID === id);
  
  // Memorizza in una matrice di dimensioni dell'immagine da creare tutti i valori previsti
  const [width, height] = objectRecord.Size.split('x').map(Number);
  const tempImageMatrix = Array.from({ length: height }, () => Array(width).fill("0"));
  
  // Popola tempImageMatrix con i valori della matrice con ID=1 o con ID=onlyMatrix se specificato
  const baseMatrixID = onlyMatrix > 0 ? onlyMatrix : 1;
  const baseMatrix = pattern.Matrices.find(m => m.ID === baseMatrixID);
  baseMatrix.Values.forEach(cell => {
    tempImageMatrix[cell.PosY][cell.PosX] = cell.Value.toString(16).toUpperCase();
  });
  
  // Se onlyMatrix è maggiore di 0, non analizzare le altre matrici
  if (onlyMatrix <= 0) {
    // Analizza le matrici con ID maggiore di 1
    pattern.Matrices.filter(m => m.ID > 1).forEach(matrix => {
      
      matrix.Values.forEach(cell => {
        
        const currentValue = tempImageMatrix[cell.PosY][cell.PosX];
        const newValue = cell.Value.toString().toUpperCase();
        
        if (transparentColorsID.includes(currentValue)) {
          tempImageMatrix[cell.PosY][cell.PosX] = newValue;
        } else {
          const orOption = matrix.OrOptions.find(o => o.Row === cell.PosY).Status;
          if (orOption) {
            tempImageMatrix[cell.PosY][cell.PosX] = orTable[currentValue][newValue];
          }
        }
      });
    });
  }

  // Crea l'immagine transcodificando i codici colori di tempImageMatrix con i colori presenti in paletteRecord
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // Disabilita l'interpolazione per immagini più nitide
  ctx.imageSmoothingEnabled = false;

  const imageData = ctx.createImageData(width, height);
  
  tempImageMatrix.forEach((row, y) => {
    row.forEach((value, x) => {
      const color = paletteColors[parseInt(value, 16)];
      const [r, g, b, a] = hexToRgb(color);
      const index = (y * width + x) * 4;
      imageData.data[index] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
      imageData.data[index + 3] = a; // Alpha channel
    });
  });
  
  ctx.putImageData(imageData, 0, 0);

  return canvas.toDataURL();
}

const orTable = {
  "0": { "0": "0", "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F" },
  "1": { "0": "1", "1": "1", "2": "3", "3": "3", "4": "5", "5": "5", "6": "7", "7": "7", "8": "9", "9": "9", "A": "B", "B": "B", "C": "D", "D": "D", "E": "F", "F": "F" },
  "2": { "0": "2", "1": "3", "2": "2", "3": "3", "4": "6", "5": "7", "6": "6", "7": "7", "8": "A", "9": "B", "A": "A", "B": "B", "C": "E", "D": "F", "E": "E", "F": "F" },
  "3": { "0": "3", "1": "3", "2": "3", "3": "3", "4": "7", "5": "7", "6": "7", "7": "7", "8": "B", "9": "B", "A": "B", "B": "B", "C": "F", "D": "F", "E": "F", "F": "F" },
  "4": { "0": "4", "1": "5", "2": "6", "3": "7", "4": "4", "5": "5", "6": "6", "7": "7", "8": "C", "9": "D", "A": "E", "B": "F", "C": "C", "D": "D", "E": "E", "F": "F" },
  "5": { "0": "5", "1": "5", "2": "7", "3": "7", "4": "5", "5": "5", "6": "7", "7": "7", "8": "D", "9": "D", "A": "F", "B": "F", "C": "D", "D": "D", "E": "F", "F": "F" },
  "6": { "0": "6", "1": "7", "2": "6", "3": "7", "4": "6", "5": "7", "6": "6", "7": "7", "8": "E", "9": "F", "A": "E", "B": "F", "C": "E", "D": "F", "E": "E", "F": "F" },
  "7": { "0": "7", "1": "7", "2": "7", "3": "7", "4": "7", "5": "7", "6": "7", "7": "7", "8": "F", "9": "F", "A": "F", "B": "F", "C": "F", "D": "F", "E": "F", "F": "F" },
  "8": { "0": "8", "1": "9", "2": "A", "3": "B", "4": "C", "5": "D", "6": "E", "7": "F", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F" },
  "9": { "0": "9", "1": "9", "2": "B", "3": "B", "4": "D", "5": "D", "6": "F", "7": "F", "8": "9", "9": "9", "A": "B", "B": "B", "C": "D", "D": "D", "E": "F", "F": "F" },
  "A": { "0": "A", "1": "B", "2": "A", "3": "B", "4": "E", "5": "F", "6": "E", "7": "F", "8": "A", "9": "B", "A": "A", "B": "B", "C": "E", "D": "F", "E": "E", "F": "F" },
  "B": { "0": "B", "1": "B", "2": "B", "3": "B", "4": "F", "5": "F", "6": "F", "7": "F", "8": "B", "9": "B", "A": "B", "B": "B", "C": "F", "D": "F", "E": "F", "F": "F" },
  "C": { "0": "C", "1": "D", "2": "E", "3": "F", "4": "C", "5": "D", "6": "E", "7": "F", "8": "C", "9": "D", "A": "E", "B": "F", "C": "C", "D": "D", "E": "E", "F": "F" },
  "D": { "0": "D", "1": "D", "2": "F", "3": "F", "4": "D", "5": "D", "6": "F", "7": "F", "8": "D", "9": "D", "A": "F", "B": "F", "C": "D", "D": "D", "E": "F", "F": "F" },
  "E": { "0": "E", "1": "F", "2": "E", "3": "F", "4": "E", "5": "F", "6": "E", "7": "F", "8": "E", "9": "F", "A": "E", "B": "F", "C": "E", "D": "F", "E": "E", "F": "F" },
  "F": { "0": "F", "1": "F", "2": "F", "3": "F", "4": "F", "5": "F", "6": "F", "7": "F", "8": "F", "9": "F", "A": "F", "B": "F", "C": "F", "D": "F", "E": "F", "F": "F" }
};



function rgbToHex(rgb) {
  const result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(rgb);
  return result ? `#${((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1).toUpperCase()}` : rgb;
}

function hexToRgb(hex) {
  if (hex === "#000000") {
    return [0, 0, 0, 0]; // Transparent color
  }
  const bigint = parseInt(hex.slice(1), 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return [r, g, b, 255]; // Opaque color
}

function getContrastingColor(hex) {
  // Convert hex to RGB
  const rgb = hexToRgb(hex);
  // Calculate the brightness of the color
  const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
  // Return black or white depending on the brightness
  return brightness > 128 ? '#000000' : '#FFFFFF';
}

function computeBrightness(hex) {
  let c = hex.replace("#", "");
  if (c.length < 6) return 255;
  let r = parseInt(c.substring(0, 2), 16);
  let g = parseInt(c.substring(2, 4), 16);
  let b = parseInt(c.substring(4, 6), 16);
  return (0.299 * r + 0.587 * g + 0.114 * b);
}

function createColorGrid(container, paletteColors) {
  const triplets = [
    [1, 2, 3], [1, 4, 5], [1, 6, 7], [1, 8, 9], [1, 10, 11], [1, 12, 13], [1, 14, 15],
    [2, 4, 6], [2, 5, 7], [2, 8, 10], [2, 9, 11], [2, 12, 14], [2, 13, 15],
    [3, 4, 7], [3, 5, 7], [3, 6, 7], [3, 8, 11], [3, 9, 11], [3, 10, 11], [3, 12, 15],
    [3, 13, 15], [3, 14, 15], [4, 8, 12], [4, 9, 13], [4, 10, 14], [4, 11, 15],
    [5, 6, 7], [5, 8, 13], [5, 9, 13], [5, 10, 15], [5, 11, 15], [5, 12, 13], [5, 14, 15],
    [6, 8, 14], [6, 9, 15], [6, 10, 14], [6, 11, 15], [6, 12, 14], [6, 13, 15],
    [7, 8, 15], [7, 9, 15], [7, 10, 15], [7, 11, 15], [7, 12, 15], [7, 13, 15], [7, 14, 15],
    [9, 10, 11], [9, 12, 13], [9, 14, 15], [10, 12, 14], [10, 13, 15], [11, 12, 15],
    [11, 13, 15], [11, 14, 15], [13, 14, 15]
  ];

  const containerWidth = container.clientWidth;
  const columnWidth = 100; // Assume each column is 100px wide
  const columns = Math.floor(containerWidth / columnWidth);

  const grid = document.createElement('div');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
  grid.style.overflowY = 'auto';

  triplets.forEach(triplet => {
    const tripletDiv = document.createElement('div');
    tripletDiv.style.border = '1px solid #ccc';
    tripletDiv.style.padding = '10px';
    tripletDiv.style.margin = '5px';
    tripletDiv.style.textAlign = 'center';
    tripletDiv.style.cursor = 'pointer';

    // Rimuovi la combo del sottotipo per il tipo "Tiles"
    if (triplet[0] === "Tiles") {
      tripletDiv.innerHTML = `
        <div style="background-color: ${paletteColors[triplet[0]]}; color: ${getContrastingColor(paletteColors[triplet[0]])};">${triplet[0]}</div>
        <div style="background-color: ${paletteColors[triplet[1]]}; color: ${getContrastingColor(paletteColors[triplet[1]])};">${triplet[1]}</div>
        <div style="background-color: ${paletteColors[triplet[2]]}; color: ${getContrastingColor(paletteColors[triplet[2]])};">${triplet[0]} + ${triplet[1]} = ${triplet[2]}</div>
      `;
    } else {
      tripletDiv.innerHTML = `
        <div style="background-color: ${paletteColors[triplet[0]]}; color: ${getContrastingColor(paletteColors[triplet[0]])};">${triplet[0]}</div>
        <div style="background-color: ${paletteColors[triplet[1]]}; color: ${getContrastingColor(paletteColors[triplet[1]])};">${triplet[1]}</div>
        <div style="background-color: ${paletteColors[triplet[2]]}; color: ${getContrastingColor(paletteColors[triplet[2]])};">${triplet[0]} + ${triplet[1]} = ${triplet[2]}</div>
      `;
    }

    tripletDiv.addEventListener('click', () => {
      document.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
      tripletDiv.classList.add('focused');
    });

    grid.appendChild(tripletDiv);
  });

  container.appendChild(grid);
}

// Funzione per inserire un nuovo record di tipo "Tiles" con sottotipo "Bitmap"
function insertNewTileRecord(record) {
  if (record.type === "Tiles") {
    record.subtype = "Bitmap";
  }
  // ...existing code per inserire il record...
}



function sanitizeCArrayName(input) {
  return input.replace(/^([^A-Za-z_])|([^A-Za-z0-9_])/g, "_");
}
function exportType2Sprites(record, exportType) {
  let basicLine=10000;
  let cArray ="";
  switch(exportType) {
    case "c":
      cArray += "// MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com)\n";
      cArray += "// -----------------------------------------------------------------------------\n";
      break;
    case "msxc":
      cArray += "/* MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com) */\n";
      cArray += "/* ----------------------------------------------------------------------------- */\n";
      break;
      case "bas":
        basicLine+=10;
        cArray += `${basicLine} ' MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com) */\n`;
        basicLine+=10;
        cArray += `${basicLine} ' ----------------------------------------------------------------------------- */\n`;
      break;
    default:
      cArray += `; MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com)\n`;
      cArray += `; -----------------------------------------------------------------------------\n`;
  }
  
  
  
  
  let totalBytes = 0;
  let sprtid=-1;
  
  record.Values.forEach(sprite => {
    sprtid++;
    const [spriteWidth, spriteHeight] = record.Size.split('x').map(Number);
    const blocksPerRow = Math.ceil(spriteWidth / 8);
    const blocksPerColumn = Math.ceil(spriteHeight / 8);

 

    switch(exportType) {
      case "c":
        cArray += `static const unsigned char sprite_${record.TagName}_${sprite.ID}[] = { // ${sprite.Name}\n`;
        break;
      case "msxc":
        cArray += `TINY spr${sprtid.toString().padStart(3, '0')}[] = { /* ${sprite.Name} */\n`;
        break;
        case "bas":
          basicLine+=10;
          cArray += `${basicLine} ' -------------- SPRITE ${sprite.Name} --------------\n`;
        break;
      default:
        cArray += `${record.TagName}_${sprite.ID}:\t; ${sprite.Name}\n`;
    }

    for (let blockY = 0; blockY < blocksPerColumn; blockY++) {
      for (let blockX = 0; blockX < blocksPerRow; blockX++) {
        if (spriteWidth === 16 && spriteHeight === 16) {
          switch(exportType) {

            case "c":
              cArray += `// -------------- BLOCK ${blockY * blocksPerRow + blockX} --------------\n`;
              break;
            case "msxc":
              cArray += `/* -------------- BLOCK ${blockY * blocksPerRow + blockX} -------------- */\n`;
              break;
            case "bas":
              basicLine+=10;
              cArray += `${basicLine} ' -------------- BLOCK ${blockY * blocksPerRow + blockX} --------------\n`;
              break;
            default:
              cArray += `; -------------- BLOCK ${blockY * blocksPerRow + blockX} --------------\n`;
          }
          
        }

        

        sprite.Matrices.forEach((matrix, matrixIndex) => {
          const patternArray = [];
          const colorArray = [];
          const orOptionArray = [];
          for (let row = 0; row < 8; row++) {
            let byte = 0;
            let color = "0";
            orOptionArray.push(matrix.OrOptions.find(r=>r.Row===row).Status?'1':'0');
            for (let col = 0; col < 8; col++) {
              const cellX = blockX * 8 + col;
              const cellY = blockY * 8 + row;
              const cell = matrix.Values.find(cell => cell.PosX === cellX && cell.PosY === cellY);

              if (cell && cell.Value.toString() !== "0") {
                byte |= (1 << (7 - col));
                color = cell.Value;
              }
            }

            patternArray.push(byte);

            //if (matrix.OrOptions && !matrix.OrOptions[row] && colorArray[row] !== "0") {
            //  color = "0";
            //}

            colorArray.push(color);
          }

          switch(exportType) {
            case "c":
              cArray += `  // Pattern `+ matrixIndex.toString() +` definition\n  ${patternArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')},\n`;
              cArray += `  // Pattern `+ matrixIndex.toString() +` colors\n  ${colorArray.map(c => `0x${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')},\n`;
              cArray += `  // Pattern `+ matrixIndex.toString() +` OR options\n  ${orOptionArray.map(c => `0x0${c.toString()}`).join(', ')},\n`;
              break;
            case "msxc":
              cArray += `  /* Pattern `+ matrixIndex.toString() +` definition */\n  ${patternArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')},\n`;
              cArray += `  /* Pattern `+ matrixIndex.toString() +` colors */\n  ${colorArray.map(c => `0x${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')},\n`;
              cArray += `  /* Pattern `+ matrixIndex.toString() +` OR options */\n  ${orOptionArray.map(c => `0x0${c.toString()}`).join(', ')},\n`;
              break;
            case "bas":
              basicLine+=10;
              cArray += `${basicLine} ' Pattern `+ matrixIndex.toString() +` definition\n`;
              basicLine+=10;
              cArray +=`${basicLine} DATA ${patternArray.map(b => `&H${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n`;
              basicLine+=10;
              cArray += `${basicLine} ' Pattern `+ matrixIndex.toString() +` colors\n`;
              basicLine+=10;
              cArray +=`${basicLine} DATA ${colorArray.map(c => `&H${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n`;
              basicLine+=10;
              cArray += `${basicLine} ' Pattern `+ matrixIndex.toString() +` OR options\n`;
              basicLine+=10;
              cArray += `${basicLine} DATA ${orOptionArray.map(c => `&H0${c.toString()}`).join(', ')}\n`;
              break;
            case "asm-sdasz80":
              cArray += `  .db ${patternArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; Pattern `+ matrixIndex.toString() +`\n`;
              cArray += `  .db ${colorArray.map(c => `0x${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; `+ matrixIndex.toString() +` colors\n`;
              cArray += `  .db ${orOptionArray.map(c => `0x0${c.toString()}`).join(', ')} ; `+ matrixIndex.toString() +` OR options\n`;
              break;
            case "asm-tniasm":
            case "asm-asmsx":
              cArray += `  db ${patternArray.map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; Pattern `+ matrixIndex.toString() +`\n`;
              cArray += `  db ${colorArray.map(c => `$${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; `+ matrixIndex.toString() +` colors\n`;
              cArray += `  db ${orOptionArray.map(c => `$0${c.toString()}`).join(', ')} ; `+ matrixIndex.toString() +` OR options\n`;
              break;
            case "asm-sjasm":       
              cArray += `  db ${patternArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; Pattern `+ matrixIndex.toString() +`\n`;
              cArray += `  db ${colorArray.map(c => `0x${c.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; `+ matrixIndex.toString() +` colors\n`;
              cArray += `  db ${orOptionArray.map(c => `0x0${c.toString()}`).join(', ')} ; `+ matrixIndex.toString() +` OR options\n`;
              break;
            case "asm-macro80":       
              cArray += `  db ${patternArray.map(b => `${b.toString(16).padStart(2, '0').toUpperCase()}h`).join(', ')} ; Pattern `+ matrixIndex.toString() +`\n`;
              cArray += `  db ${colorArray.map(c => `${c.toString(16).padStart(2, '0').toUpperCase()}h`).join(', ')} ; `+ matrixIndex.toString() +` colors\n`;
              cArray += `  db ${orOptionArray.map(c => `0${c.toString()}h`).join(', ')} ; `+ matrixIndex.toString() +` OR options\n`;
              break;
          }
         
  
          totalBytes += patternArray.length + colorArray.length + orOptionArray.length;

        });

        
      }
    }

    if (exportType === "c" || exportType === "msxc") {
      cArray += `};\n`;
    }
  });
  switch(exportType) {
    case "c":
      cArray += `// Total bytes: ${totalBytes}\n`;
      cArray += "\n\n// \"OR options\" values are the CC bit value for each row into sprite color table\n";
      break;
    case "msxc":
      cArray += `/* Total bytes: ${totalBytes} */\n`;
      cArray += "\n\n/* \"OR options\" values are the CC bit value for each row into sprite color table */\n";
      break;
    case "bas":
      basicLine+=10;
      cArray += `${basicLine} ' Total bytes: ${totalBytes}\n`;
      basicLine+=10;
      cArray += `${basicLine} ' \"OR options\" values are the CC bit value for each row into sprite color table\n`;
      break;
    default:
      cArray += `; Total bytes: ${totalBytes}\n`;
      cArray += "\n\n; \"OR options\" values are the CC bit value for each row into sprite color table\n";
  }
  
  
  return cArray;
}

function removePaletteExportText(text) {
  const marker1 = "// -----------------------------------------------------------------------------\n";
  const marker2 = "// Custom palette | Format: [x|R:3|x|B:3] [x:5|G:3] (v9938)\n";


  const firstOccurrence = text.indexOf(marker1);
  if (firstOccurrence === -1) {

    return text;
  }


  const secondOccurrence = text.indexOf(marker1, firstOccurrence + marker1.length);
  if (secondOccurrence === -1) {

    return text;
  }


  const removalStart = secondOccurrence + marker1.length;


  const marker2Index = text.indexOf(marker2, removalStart);
  if (marker2Index === -1) {

    return text;
  }

  // Ricostruisco il testo: parte iniziale fino alla fine della seconda occorrenza di marker1
  // + tutto quello che segue dal marker2 in poi
  const nuovoTesto = text.slice(0, removalStart) + text.slice(marker2Index);

  return nuovoTesto;
}

function exportMaps(record, exportType) {
  let basicLine=10000;
  let cArray ="";
  switch(exportType) {
    case "c":
      cArray += "// MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com)\n";
      cArray += "// -----------------------------------------------------------------------------\n";
      break;
    case "msxc":
      cArray += "/* MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com) */\n";
      cArray += "/* ----------------------------------------------------------------------------- */\n";
      break;
      case "bas":
        basicLine+=10;
        cArray += `${basicLine} ' MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com) */\n`;
        basicLine+=10;
        cArray += `${basicLine} ' ----------------------------------------------------------------------------- */\n`;
      break;
    default:
      cArray += `; MSXDevTool Visual Studio Code Extension  -  Fausto Pracek (fpracek@gmail.com)\n`;
      cArray += `; -----------------------------------------------------------------------------\n`;
  }

  record.Values.forEach(value => {
    const totalBytes = value.Map.length;
    let mapArray = '';

    value.Map.forEach(cell => {
      switch(exportType) {
        case "c":
        case "msxc":
        case "asm-sdasz80":
        case "asm-sjasm": 
          mapArray += `0x${cell.TileId.toString(16).padStart(2, '0').toUpperCase()}, `;
          break;
        case "bas":
          mapArray += `&H${cell.TileId.toString(16).padStart(2, '0').toUpperCase()}, `;
          break;
        case "asm-tniasm":
        case "asm-asmsx":
          mapArray += `$${cell.TileId.toString(16).padStart(2, '0').toUpperCase()}, `;
          break;
        case "asm-macro80":       
          mapArray += `${cell.TileId.toString(16).padStart(2, '0').toUpperCase()}h, `;
          break;
      }
     
    });
    mapArray = mapArray.slice(0, -2); // Remove the trailing comma and space
    switch(exportType) {
      case "c":
        cArray += `const unsigned char ${record.TagName}_${value.ID}[] = { ${mapArray} };\n`;
        cArray += `\n\n// Total bytes: ${totalBytes}\n`;
        break;
      case "msxc":
        cArray += `TINY Map[] = { ${mapArray} };\n`;
        cArray += `\n/n\* Total bytes: ${totalBytes} */\n`;
        break;
      case "bas":
        basicLine+=10;
        cArray += `${basicLine} DATA ${mapArray}\n`;
        basicLine+=10;
        cArray += `${basicLine} ' Total bytes: ${totalBytes}\n`;
        break;
      default:
        cArray += `${record.TagName}_${value.ID}:\n${mapArray}\n`;
        cArray += `\n\n; Total bytes: ${totalBytes}\n`;
    }
  });
  return cArray;
}

function generatePaletteImage(paletteRecord) {
  const colors = paletteRecord.Values.map(value => value.color);
  const squareSize = 8;
  const canvasSize = Math.ceil(Math.sqrt(colors.length)) * squareSize;
  const canvas = document.createElement('canvas');
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  const ctx = canvas.getContext('2d');

  colors.forEach((color, index) => {
    const x = (index % Math.ceil(Math.sqrt(colors.length))) * squareSize;
    const y = Math.floor(index / Math.ceil(Math.sqrt(colors.length))) * squareSize;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, squareSize, squareSize);
  });

  return canvas.toDataURL();
}

/**
 * Checks if the TagName of the given record is unique in the datastore.
 * @param {Array} dataStore - The datastore containing all records.
 * @param {Object} record - The record to check.
 * @returns {boolean} - Returns true if the TagName is unique, false otherwise.
 */
function checkTagName(dataStore, record) {
  let esito=true;
  dataStore.forEach(item => {
    if (item.TagName === record.TagName && (item.ID !== record.ID || item.Type !== record.Type)) {
      esito=false;
    }
  });
  return esito;
}