/**
 * MSXDev Tool Extension for VS Code
 * Copyright (C) 2025  Fausto Pracek
 *
 * This file is part of MSXDev Tool Extension for VS Code.
 *
 * MSXDev Tool Extension for VS Code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MSXDev Tool Extension for VS Code is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MSXDev Tool Extension for VS Code. If not, see <https://www.gnu.org/licenses/>.
 */





function CreateCode(codeGeneratorItems, codeGeneratorScreenMode, codGeneratorMachine) {
  console.log(codeGeneratorItems);
  let codeString = "// Generated by MSXDev Tool Extension for VS Code\n\n";
  codeString += '// =======\n';
  codeString += '// INCLUDE\n';
  codeString += '// =======\n';
  codeString += '#include "msxgl.h"\n';
  codeString += '#include "bios.h"\n';

  if (codeGeneratorItems.some(item => item.Type === 'Tiles')) {
    codeString += '#include "vdp.h"\n';
  }
  if (codeGeneratorItems.some(item => item.Type === 'Fonts')) {
    codeString += '#include "print.h"\n';
  }

  codeString += '#include "tile.h"\n';
  codeString += '\n';

  // Add arrays for each item using existing export functions
  codeGeneratorItems.forEach(item => {
    switch (item.Type) {
      case 'Palettes':
        codeString += exportPalette(item, 'C (MSXgl)') + '\n';
        break;
      case 'Tiles':
        codeString += exportTiles(item, 'C (MSXgl)') + '\n';
        break;
      case 'Fonts':
        codeString += exportFonts(item, 'C (MSXgl)') + '\n';
        break;
      case 'Sprites':
        codeString += exportSprites(item, 'C (MSXgl)') + '\n';
        break;
      case 'Maps':
        codeString += exportMaps(item, 'C (MSXgl)') + '\n';
        break;
      case 'Images':
        codeString += exportImages(item, 'C (MSXgl)') + '\n';
        break;
      default:
        throw new Error('Unsupported item type');
    }
  });

  codeString += '// ====\n';
  codeString += '// MAIN\n';
  codeString += '// ====\n';
  codeString += 'main()\n{\n';

  // Add VDP_SetMode based on codeGeneratorScreenMode
  switch (codeGeneratorScreenMode.toString()) {
    case '0':
      if (codGeneratorMachine == 'MSX1') {
        codeString += '\tVDP_SetMode(VDP_MODE_SCREEN0_W40);\n';
        codeString += '\tVDP_SetLayoutTable(VDP_T1_ADDR_NT);\n';
      } else {
        codeString += '\tVDP_SetMode(VDP_MODE_SCREEN0);\n';
        codeString += '\tVDP_SetLayoutTable(VDP_T2_ADDR_NT);\n';
      }
      break;
    case '1':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN1);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G1_ADDR_NT);\n';
      break;
    case '2':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN2);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G2_ADDR_NT);\n';
      break;
    case '3':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN3);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_MC_ADDR_NT);\n';
      break;
    case '4':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN4);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G3_ADDR_NT);\n';
      break;
    case '5':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN5);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G4_ADDR_NT);\n';
      break;
    case '6':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN6);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G5_ADDR_NT);\n';
      break;
    case '7':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN7);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G6_ADDR_NT);\n';
      break;
    case '8':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN8);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '10':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN10);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '11':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN11);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    case '12':
      codeString += '\tVDP_SetMode(VDP_MODE_SCREEN12);\n';
      codeString += '\tVDP_SetLayoutTable(VDP_G7_ADDR_NT);\n';
      break;
    default:
      console.log(codeGeneratorScreenMode);
  }

  codeString += '\n';
  
  // Add Palette functions for each Tiles record
  codeGeneratorItems.forEach(item => {
    if (item.Type === 'Palettes') {
      const palettesData = `Tile_${item.ID}`;
      codeString += `\tVDP_SetPalette(${palettesData});\n`;
    }
  });
  codeString += '\n';

  // Add Print_SetBitmapFont for the first Fonts record
  const firstSprite = codeGeneratorItems.find(item => item.Type === 'Sprites' && item.subtype==="Type 1" && (item.Size === '8x8' || item.Size === '16x16'));
  if (firstSprite) {
    const spriteData = `Sprite_${firstSprite.ID}`;
    const spriteCount = firstSprite.Size==="8x8"?firstSprite.Values.length:firstSprite.Values.length*4;
    codeString += `\tVDP_LoadSpritePattern(${spriteData},0,${spriteCount});\n`;
  }

  // Add Print_SetBitmapFont for the first Fonts record
  const firstFont = codeGeneratorItems.find(item => item.Type === 'Fonts');
  if (firstFont) {
    const fontName = `FontSet_${firstFont.ID}`;

    switch (firstFont.Values[0].exportType) {
      case 'Text':
        codeString += `\tPrint_SetTextFont(${fontName},0); // This function requires PRINT_USE_TEXT compile option to be set to TRUE\n`;
        break;
      case 'Sprite':
        codeString += `\tPrint_SetSpriteFont((${fontName}, 0, 0); // This function requires PRINT_USE_SPRITE compile option to be set to TRUE\n`;
        break;
      case 'VRAM':
        codeString += `\tPrint_SetVRAMFont(${fontName},212,RGB8(4,4,2)); // This function requires PRINT_USE_VRAM compile option to be set to TRUE\n`;
        break;
      case 'Bitmap':
        codeString += `\tPrint_SetBitmapFont(${fontName}); // This function requires PRINT_USE_BITMAP compile option to be set to TRUE.\n`;
        break;
      case 'Bitmap trans':
        codeString += `\tPrint_SetBitmapFont(${fontName}); // This function requires PRINT_USE_BITMAP compile option to be set to TRUE.\n`;
        codeString += `\tPrint_SetMode(PRINT_MODE_BITMAP_TRANS)\n`;
        break
    }
    
    
    codeString += `\tPrint_SetBitmapFont(${fontName});\n`;
  }

  // Add Tile functions for the first Tiles record
  const firstTile = codeGeneratorItems.find(item => item.Type === 'Tiles');
  if (firstTile) {
    const tilesData = `Tile_${firstTile.ID}`;
    codeString += `\tTile_SelectBank(0);\n`;
    codeString += `\tTile_SetDrawPage(0);\n`;
    codeString += `\tTile_LoadBank(0, ${tilesData}, ${firstTile.Values.length.toString()});\n`;
  }

  codeString += '}';

  return codeString;
}

function rgbToMsx(hexColor) {
  // Removes the initial "#", if present
  const cleanHex = hexColor.replace(/^#/, "");

  // Checks that the string is 6 hexadecimal characters long
  if (cleanHex.length !== 6) {
    throw new Error("Invalid color format: must be #rrggbb");
  }

  // Extracts the R, G, and B components in decimal (0-255)
  const rDec = parseInt(cleanHex.slice(0, 2), 16);
  const gDec = parseInt(cleanHex.slice(2, 4), 16);
  const bDec = parseInt(cleanHex.slice(4, 6), 16);

  // Converts each channel from [0..255] to [0..15].
  // Using division by 17 and rounding: 255/17 = 15
  const r4 = Math.round(rDec / 17);
  const g4 = Math.round(gDec / 17);
  const b4 = Math.round(bDec / 17);

  // Returns the string with the channel names
  return `R=${r4}, G=${g4}, B=${b4}`;
}
function getImageFromObject(id, objectRecord, paletteRecord, onlyMatrix = -1) {
  // Deserializza l'attributo Values di paletteRecord
  const paletteValues = paletteRecord.Values;
  
  // Crea un array di tutti gli ID del paletteRecord con colore #000000
  const transparentColorsID = paletteValues.filter(color => color.color === "#000000").map(color => color.id);
  
  // Crea un array di tutti gli ID del paletteRecord
  const paletteColors = paletteValues.map(color => color.color);
  
  // Deserializza l'attributo Values di objectRecord
  const objectInfo = objectRecord.Values;
  
  // Individua il pattern in Values di objectInfo con ID uguale a quello ricevuto come parametro
  const pattern = objectInfo.find(o => o.ID === id);
  
  // Memorizza in una matrice di dimensioni dell'immagine da creare tutti i valori previsti
  const [width, height] = objectRecord.Size.split('x').map(Number);
  const tempImageMatrix = Array.from({ length: height }, () => Array(width).fill("0"));
  
  // Popola tempImageMatrix con i valori della matrice con ID=1 o con ID=onlyMatrix se specificato
  const baseMatrixID = onlyMatrix > 0 ? onlyMatrix : 1;
  const baseMatrix = pattern.Matrices.find(m => m.ID === baseMatrixID);
  baseMatrix.Values.forEach(cell => {
    tempImageMatrix[cell.PosY][cell.PosX] = cell.Value.toString(16).toUpperCase();
  });
  
  // Se onlyMatrix Ã¨ maggiore di 0, non analizzare le altre matrici
  if (onlyMatrix <= 0) {
    // Analizza le matrici con ID maggiore di 1
    pattern.Matrices.filter(m => m.ID > 1).forEach(matrix => {
      
      matrix.Values.forEach(cell => {
        
        const currentValue = tempImageMatrix[cell.PosY][cell.PosX];
        const newValue = cell.Value.toString().toUpperCase();
        
        if (transparentColorsID.includes(currentValue)) {
          tempImageMatrix[cell.PosY][cell.PosX] = newValue;
        } else {
          const orOption = matrix.OrOptions.find(o => o.Row === cell.PosY).Status;
          if (orOption) {
            tempImageMatrix[cell.PosY][cell.PosX] = orTable[currentValue][newValue];
          }
        }
      });
    });
  }

  // Crea l'immagine transcodificando i codici colori di tempImageMatrix con i colori presenti in paletteRecord
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // Disabilita l'interpolazione per immagini piÃ¹ nitide
  ctx.imageSmoothingEnabled = false;

  const imageData = ctx.createImageData(width, height);
  
  tempImageMatrix.forEach((row, y) => {
    row.forEach((value, x) => {
      const color = paletteColors[parseInt(value, 16)];
      const [r, g, b, a] = hexToRgb(color);
      const index = (y * width + x) * 4;
      imageData.data[index] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
      imageData.data[index + 3] = a; // Alpha channel
    });
  });
  
  ctx.putImageData(imageData, 0, 0);

  return canvas.toDataURL();
}

const orTable = {
  "0": { "0": "0", "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F" },
  "1": { "0": "1", "1": "1", "2": "3", "3": "3", "4": "5", "5": "5", "6": "7", "7": "7", "8": "9", "9": "9", "A": "B", "B": "B", "C": "D", "D": "D", "E": "F", "F": "F" },
  "2": { "0": "2", "1": "3", "2": "2", "3": "3", "4": "6", "5": "7", "6": "6", "7": "7", "8": "A", "9": "B", "A": "A", "B": "B", "C": "E", "D": "F", "E": "E", "F": "F" },
  "3": { "0": "3", "1": "3", "2": "3", "3": "3", "4": "7", "5": "7", "6": "7", "7": "7", "8": "B", "9": "B", "A": "B", "B": "B", "C": "F", "D": "F", "E": "F", "F": "F" },
  "4": { "0": "4", "1": "5", "2": "6", "3": "7", "4": "4", "5": "5", "6": "6", "7": "7", "8": "C", "9": "D", "A": "E", "B": "F", "C": "C", "D": "D", "E": "E", "F": "F" },
  "5": { "0": "5", "1": "5", "2": "7", "3": "7", "4": "5", "5": "5", "6": "7", "7": "7", "8": "D", "9": "D", "A": "F", "B": "F", "C": "D", "D": "D", "E": "F", "F": "F" },
  "6": { "0": "6", "1": "7", "2": "6", "3": "7", "4": "6", "5": "7", "6": "6", "7": "7", "8": "E", "9": "F", "A": "E", "B": "F", "C": "E", "D": "F", "E": "E", "F": "F" },
  "7": { "0": "7", "1": "7", "2": "7", "3": "7", "4": "7", "5": "7", "6": "7", "7": "7", "8": "F", "9": "F", "A": "F", "B": "F", "C": "F", "D": "F", "E": "F", "F": "F" },
  "8": { "0": "8", "1": "9", "2": "A", "3": "B", "4": "C", "5": "D", "6": "E", "7": "F", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F" },
  "9": { "0": "9", "1": "9", "2": "B", "3": "B", "4": "D", "5": "D", "6": "F", "7": "F", "8": "9", "9": "9", "A": "B", "B": "B", "C": "D", "D": "D", "E": "F", "F": "F" },
  "A": { "0": "A", "1": "B", "2": "A", "3": "B", "4": "E", "5": "F", "6": "E", "7": "F", "8": "A", "9": "B", "A": "A", "B": "B", "C": "E", "D": "F", "E": "E", "F": "F" },
  "B": { "0": "B", "1": "B", "2": "B", "3": "B", "4": "F", "5": "F", "6": "F", "7": "F", "8": "B", "9": "B", "A": "B", "B": "B", "C": "F", "D": "F", "E": "F", "F": "F" },
  "C": { "0": "C", "1": "D", "2": "E", "3": "F", "4": "C", "5": "D", "6": "E", "7": "F", "8": "C", "9": "D", "A": "E", "B": "F", "C": "C", "D": "D", "E": "E", "F": "F" },
  "D": { "0": "D", "1": "D", "2": "F", "3": "F", "4": "D", "5": "D", "6": "F", "7": "F", "8": "D", "9": "D", "A": "F", "B": "F", "C": "D", "D": "D", "E": "F", "F": "F" },
  "E": { "0": "E", "1": "F", "2": "E", "3": "F", "4": "E", "5": "F", "6": "E", "7": "F", "8": "E", "9": "F", "A": "E", "B": "F", "C": "E", "D": "F", "E": "E", "F": "F" },
  "F": { "0": "F", "1": "F", "2": "F", "3": "F", "4": "F", "5": "F", "6": "F", "7": "F", "8": "F", "9": "F", "A": "F", "B": "F", "C": "F", "D": "F", "E": "F", "F": "F" }
};



function rgbToHex(rgb) {
  const result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(rgb);
  return result ? `#${((1 << 24) + (parseInt(result[1]) << 16) + (parseInt(result[2]) << 8) + parseInt(result[3])).toString(16).slice(1).toUpperCase()}` : rgb;
}

function hexToRgb(hex) {
  if (hex === "#000000") {
    return [0, 0, 0, 0]; // Transparent color
  }
  const bigint = parseInt(hex.slice(1), 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return [r, g, b, 255]; // Opaque color
}

function getContrastingColor(hex) {
  // Convert hex to RGB
  const rgb = hexToRgb(hex);
  // Calculate the brightness of the color
  const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
  // Return black or white depending on the brightness
  return brightness > 128 ? '#000000' : '#FFFFFF';
}

function computeBrightness(hex) {
  let c = hex.replace("#", "");
  if (c.length < 6) return 255;
  let r = parseInt(c.substring(0, 2), 16);
  let g = parseInt(c.substring(2, 4), 16);
  let b = parseInt(c.substring(4, 6), 16);
  return (0.299 * r + 0.587 * g + 0.114 * b);
}

function createColorGrid(container, paletteColors) {
  const triplets = [
    [1, 2, 3], [1, 4, 5], [1, 6, 7], [1, 8, 9], [1, 10, 11], [1, 12, 13], [1, 14, 15],
    [2, 4, 6], [2, 5, 7], [2, 8, 10], [2, 9, 11], [2, 12, 14], [2, 13, 15],
    [3, 4, 7], [3, 5, 7], [3, 6, 7], [3, 8, 11], [3, 9, 11], [3, 10, 11], [3, 12, 15],
    [3, 13, 15], [3, 14, 15], [4, 8, 12], [4, 9, 13], [4, 10, 14], [4, 11, 15],
    [5, 6, 7], [5, 8, 13], [5, 9, 13], [5, 10, 15], [5, 11, 15], [5, 12, 13], [5, 14, 15],
    [6, 8, 14], [6, 9, 15], [6, 10, 14], [6, 11, 15], [6, 12, 14], [6, 13, 15],
    [7, 8, 15], [7, 9, 15], [7, 10, 15], [7, 11, 15], [7, 12, 15], [7, 13, 15], [7, 14, 15],
    [9, 10, 11], [9, 12, 13], [9, 14, 15], [10, 12, 14], [10, 13, 15], [11, 12, 15],
    [11, 13, 15], [11, 14, 15], [13, 14, 15]
  ];

  const containerWidth = container.clientWidth;
  const columnWidth = 100; // Assume each column is 100px wide
  const columns = Math.floor(containerWidth / columnWidth);

  const grid = document.createElement('div');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
  grid.style.overflowY = 'auto';

  triplets.forEach(triplet => {
    const tripletDiv = document.createElement('div');
    tripletDiv.style.border = '1px solid #ccc';
    tripletDiv.style.padding = '10px';
    tripletDiv.style.margin = '5px';
    tripletDiv.style.textAlign = 'center';
    tripletDiv.style.cursor = 'pointer';

    // Rimuovi la combo del sottotipo per il tipo "Tiles"
    if (triplet[0] === "Tiles") {
      tripletDiv.innerHTML = `
        <div style="background-color: ${paletteColors[triplet[0]]}; color: ${getContrastingColor(paletteColors[triplet[0]])};">${triplet[0]}</div>
        <div style="background-color: ${paletteColors[triplet[1]]}; color: ${getContrastingColor(paletteColors[triplet[1]])};">${triplet[1]}</div>
        <div style="background-color: ${paletteColors[triplet[2]]}; color: ${getContrastingColor(paletteColors[triplet[2]])};">${triplet[0]} + ${triplet[1]} = ${triplet[2]}</div>
      `;
    } else {
      tripletDiv.innerHTML = `
        <div style="background-color: ${paletteColors[triplet[0]]}; color: ${getContrastingColor(paletteColors[triplet[0]])};">${triplet[0]}</div>
        <div style="background-color: ${paletteColors[triplet[1]]}; color: ${getContrastingColor(paletteColors[triplet[1]])};">${triplet[1]}</div>
        <div style="background-color: ${paletteColors[triplet[2]]}; color: ${getContrastingColor(paletteColors[triplet[2]])};">${triplet[0]} + ${triplet[1]} = ${triplet[2]}</div>
      `;
    }

    tripletDiv.addEventListener('click', () => {
      document.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
      tripletDiv.classList.add('focused');
    });

    grid.appendChild(tripletDiv);
  });

  container.appendChild(grid);
}

// Funzione per inserire un nuovo record di tipo "Tiles" con sottotipo "Bitmap"
function insertNewTileRecord(record) {
  if (record.type === "Tiles") {
    record.subtype = "Bitmap";
  }
  // ...existing code per inserire il record...
}

function exportPalette(palette, exportType) {
  const paletteId = palette.ID;
  const paletteValues = palette.Values;
  const cArrayName = `Palette_${paletteId}`;
  
  let cArray = getCommentedCode("Palette set " + palette.Description,exportType)+"\n";
  let totalBytes = 0;

  if (exportType === "C" || exportType === "C (MSXgl)") {
    cArray += `const unsigned char ${cArrayName}[] = {\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  0x${r.toString(16).padStart(2, '0').toUpperCase()}, 0x${g.toString(16).padStart(2, '0').toUpperCase()}, 0x${b.toString(16).padStart(2, '0').toUpperCase()} // ${color.id} ${color.color.toUpperCase()}`;
      if (index < paletteValues.length - 1) {
        cArray += ',\n';
      }
      totalBytes += 3;
    });
    cArray += `\n};\n`;
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "Assembly (binary)") {
    cArray += `${cArrayName}:\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  .db %${r.toString(2).padStart(8, '0')}, %${g.toString(2).padStart(8, '0')}, %${b.toString(2).padStart(8, '0')} ; ${color.id} ${color.color.toUpperCase()}\n`;
      totalBytes += 3;
    });
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "Assembly (exadecimal)") {
    cArray += `${cArrayName}:\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  .db 0x${r.toString(16).padStart(2, '0').toUpperCase()}, 0x${g.toString(16).padStart(2, '0').toUpperCase()}, 0x${b.toString(16).padStart(2, '0').toUpperCase()} ; ${color.id} ${color.color.toUpperCase()}\n`;
      totalBytes += 3;
    });
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "Assembly (MACRO80)") {
    cArray += `${cArrayName}:\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  DEFB 0${r.toString(16).padStart(2, '0').toUpperCase()}H, 0${g.toString(16).padStart(2, '0').toUpperCase()}H, 0${b.toString(16).padStart(2, '0').toUpperCase()}H ; ${color.id} ${color.color.toUpperCase()}\n`;
      totalBytes += 3;
    });
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "Pascal") {
    cArray += `${cArrayName}: array[1..${paletteValues.length}] of byte = (\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  $${r.toString(16).padStart(2, '0').toUpperCase()}, $${g.toString(16).padStart(2, '0').toUpperCase()}, $${b.toString(16).padStart(2, '0').toUpperCase()} ; ${color.id} ${color.color.toUpperCase()}`;
      if (index < paletteValues.length - 1) {
        cArray += ',\n';
      }
      totalBytes += 3;
    });
    cArray += `\n);\n`;
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "MSX-BASIC") {
    cArray += `${cArrayName}:\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  DATA ${r}, ${g}, ${b} : REM ${color.id} ${color.color.toUpperCase()}\n`;
      totalBytes += 3;
    });
    cArray += getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  } else if (exportType === "MSX-C") {
    cArray += `unsigned char ${cArrayName}[] = {\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  0x${r.toString(16).padStart(2, '0').toUpperCase()}, 0x${g.toString(16).padStart(2, '0').toUpperCase()}, 0x${b.toString(16).padStart(2, '0').toUpperCase()} // ${color.id} ${color.color.toUpperCase()}`;
      if (index < paletteValues.length - 1) {
        cArray += ',\n';
      }
      totalBytes += 3;
    });
    cArray += `\n};\n`;
    cArray +=getCommentedCode("Total bytes: " + totalBytes.toString(),exportType)+"\n";
  } else {
    cArray += `const unsigned char ${cArrayName}[] = {\n`;
    paletteValues.forEach((color, index) => {
      const [r, g, b] = hexToRgb(color.color);
      cArray += `  0x${r.toString(16).padStart(2, '0').toUpperCase()}, 0x${g.toString(16).padStart(2, '0').toUpperCase()}, 0x${b.toString(16).padStart(2, '0').toUpperCase()} // ${color.id} ${color.color.toUpperCase()}`;
      if (index < paletteValues.length - 1) {
        cArray += ',\n';
      }
      totalBytes += 3;
    });
    cArray += `\n};\n`;
    cArray += getCommentedCode("Total bytes: "+totalBytes.toString(),exportType)+"\n";
  }

  return cArray;
}

function exportTiles(record, exportType) {
  if (record.Subtype === "Standard") {
    return exportStandardTiles(record, exportType);
  } else if (record.Subtype === "Bitmap") {
    return exportBitmapTiles(record, exportType);
  }
}

function exportStandardTiles(record, exportType) {
  const tiles = record.Values.map(value => {
    const matrix = value.Matrices.find(m => m.ID === 1);
    const colors = [...new Set(matrix.Values.map(cell => cell.Value))];
    const color1 = colors[0];
    const color2 = colors[1];
    const chosenColor = color1; // Choose one of the two colors
    const tileArray = [];
    for (let row = 0; row < 8; row++) {
      let byte = 0;
      for (let col = 0; col < 8; col++) {
        const cell = matrix.Values.find(cell => cell.PosY === row && cell.PosX === col);
        if (cell.Value === chosenColor) {
          byte |= (1 << (7 - col));
        }
      }
      tileArray.push(byte);
    }
    if (exportType === "Assembly (binary)") {
      return `Tile_${record.ID}_${value.ID}:\n  .db ${tileArray.map(b => `%${b.toString(2).padStart(8, '0')}`).join(', ')}\n; Total bytes: ${tileArray.length}`;
    } else if (exportType === "Assembly (exadecimal)") {
      return `Tile_${record.ID}_${value.ID}:\n  .db ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n; Total bytes: ${tileArray.length}`;
    } else if (exportType === "Assembly (MACRO80)") {
      return `Tile_${record.ID}_${value.ID}:\n  DEFB ${tileArray.map(b => `0${b.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')}\n; Total bytes: ${tileArray.length}`;
    } else if (exportType === "Pascal") {
      return `Tile_${record.ID}_${value.ID}: array[1..8] of byte = (${tileArray.map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')});\n{Total bytes: ${tileArray.length}}`;
    } else if (exportType === "MSX-BASIC") {
      return `Tile_${record.ID}_${value.ID}:\n  DATA ${tileArray.map(b => b.toString(10)).join(', ')} : REM ${value.ID} ${value.Name}\nREM Total bytes: ${tileArray.length}`;
    } else if (exportType === "MSX-C") {
      return `unsigned char Tile_${record.ID}_${value.ID}[] = { ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; /* ${value.ID} ${value.Name} */\n/* Total bytes: ${tileArray.length} */`;
    } else {
      return `const unsigned char Tile_${record.ID}_${value.ID}[] = { ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; // ${value.ID} ${value.Name}\n// Total bytes: ${tileArray.length}`;
    }
  });
  const totalBytes = tiles.reduce((sum, tile) => {
    const matches = tile.match(/0x[0-9A-F]{2}/g);
    return sum + (matches ? matches.length : 0);
  }, 0);
  return getCommentedCode("Tiles set " + record.Description, exportType) + "\n" + tiles.join('\n') + "\n" + getCommentedCode("Total bytes: " + totalBytes.toString(), exportType) + "\n";
}

function exportBitmapTiles(record, exportType) {
  const [width, height] = record.Size.split('x').map(Number);
  const halfWidth = width / 2;
  if (exportType === "C (MSXgl)") {
    return exportBitmapTilesMSXgl(record, width, height, halfWidth,exportType);
  } else {
    const tiles = record.Values.map(value => {
      const matrix = value.Matrices.find(m => m.ID === 1);
      const tileArray = Array.from({ length: height }, () => Array(halfWidth).fill(0));
      matrix.Values.forEach(cell => {
        const byteIndex = Math.floor(cell.PosX / 2);
        const nibble = cell.PosX % 2 === 0 ? (cell.Value << 4) : cell.Value;
        tileArray[cell.PosY][byteIndex] |= nibble;
      });
      if (exportType === "Assembly (binary)") {
        return `Tile_${record.ID}_${value.ID}:\n  .db ${tileArray.flat().map(b => `%${b.toString(2).padStart(8, '0')}`).join(', ')}\n; Total bytes: ${tileArray.flat().length}`;
      } else if (exportType === "Assembly (exadecimal)") {
        return `Tile_${record.ID}_${value.ID}:\n  .db ${tileArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n; Total bytes: ${tileArray.flat().length}`;
      } else if (exportType === "Assembly (MACRO80)") {
        return `Tile_${record.ID}_${value.ID}:\n  DEFB ${tileArray.flat().map(b => `0${b.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')}\n; Total bytes: ${tileArray.flat().length}`;
      } else if (exportType === "Pascal") {
        return `Tile_${record.ID}_${value.ID}: array[1..${height}] of byte = (${tileArray.flat().map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')});\n{Total bytes: ${tileArray.flat().length}}`;
      } else if (exportType === "MSX-BASIC") {
        return `Tile_${record.ID}_${value.ID}:\n  DATA ${tileArray.flat().map(b => b.toString(10)).join(', ')} : REM ${value.ID} ${value.Name}\nREM Total bytes: ${tileArray.flat().length}`;
      } else if (exportType === "MSX-C") {
        return `unsigned char Tile_${record.ID}_${value.ID}[] = { ${tileArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; /* ${value.ID} ${value.Name} */\n/* Total bytes: ${tileArray.flat().length} */`;
      } else {
        return `const unsigned char Tile_${record.ID}_${value.ID}[] = { ${tileArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; // ${value.ID} ${value.Name}\n// Total bytes: ${tileArray.flat().length}`;
      }
    });

    const totalBytes = tiles.reduce((sum, tile) => {
      const matches = tile.match(/0x[0-9A-F]{2}/g);
      return sum + (matches ? matches.length : 0);
    }, 0);
    return getCommentedCode("Tiles set " + record.Description,exportType)+"\n"+tiles.join('\n')+"\n"+ getCommentedCode("Total bytes: "+ totalBytes.toString(),exportType)+"\n";
  }
}

function exportFonts(record, exportType) {
  if (exportType === "C (MSXgl)") {
    const [fontWidth, fontHeight] = record.Size.split('x').map(Number);
    const [dataWidth, dataHeight] = record.FontSpaces.split('x').map(Number);
    const firstChar = parseInt(record.FirstFontChar, 10);
    const lastChar = parseInt(record.LastFontChar, 10);

    let cArray = `const unsigned char FontSet_${record.ID} [] ={\n`;
    cArray += `\t0x${dataWidth.toString(16).toUpperCase()}${dataHeight.toString(16).toUpperCase()}, // Data size [x|y]\n`;
    cArray += `\t0x${fontWidth.toString(16).toUpperCase()}${fontHeight.toString(16).toUpperCase()}, // Font size [x|y]\n`;
    cArray += `\t0x${firstChar.toString(16).padStart(2, '0').toUpperCase()}, // First character ASCII code ('${String.fromCharCode(firstChar)}')\n`;
    cArray += `\t0x${lastChar.toString(16).padStart(2, '0').toUpperCase()}, // Last character ASCII code ('${String.fromCharCode(lastChar)}')\n`;

    let totalBytes = 4; // Initial bytes for the header

    record.Values.forEach((value, index) => {
      const matrix = value.Matrices.find(m => m.ID === 1);
      const tileArray = [];
      for (let row = 0; row < fontHeight; row++) {
        let byte = 0;
        for (let col = 0; col < fontWidth; col++) {
          const cell = matrix.Values.find(cell => cell.PosY === row && cell.PosX === col);
          if (cell && cell.Value !== "0") {
            byte |= (1 << (7 - col));
          }
        }
        tileArray.push(byte);
      }
      cArray += getCommentedCode("Font[" + index.toString()+"]",exportType)+"\n";
      tileArray.forEach(byte => {
        cArray += `\t0x${byte.toString(16).padStart(2, '0').toUpperCase()}, /* ${byte.toString(2).padStart(8, '0').replace(/0/g, '.').replace(/1/g, '#')} */\n`;
        totalBytes += 1;
      });
    });

    cArray += `};\n`;
    cArray += getCommentedCode("Total bytes: "+totalBytes.toString(),exportType)+"\n";
    return getCommentedCode("Fonts set " + record.Description,exportType)+"\n" + cArray;
  } else {
    const tiles = record.Values.map(value => {
      const matrix = value.Matrices.find(m => m.ID === 1);
      const colors = [...new Set(matrix.Values.map(cell => cell.Value))];
      const color1 = colors[0];
      const color2 = colors[1];
      const chosenColor = color1; // Choose one of the two colors
      const tileArray = [];
      for (let row = 0; row < 8; row++) {
        let byte = 0;
        for (let col = 0; col < 8; col++) {
          const cell = matrix.Values.find(cell => cell.PosY === row && cell.PosX === col);
          if (cell.Value === chosenColor) {
            byte |= (1 << (7 - col));
          }
        }
        tileArray.push(byte);
      }
      if (exportType === "Assembly (binary)") {
        return `Font_${record.ID}_${value.ID}:\n  .db ${tileArray.map(b => `%${b.toString(2).padStart(8, '0')}`).join(', ')}\n; Total bytes: ${tileArray.length}`;
      } else if (exportType === "Assembly (exadecimal)") {
        return `Font_${record.ID}_${value.ID}:\n  .db ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n; Total bytes: ${tileArray.length}`;
      } else if (exportType === "Assembly (MACRO80)") {
        return `Font_${record.ID}_${value.ID}:\n  DEFB ${tileArray.map(b => `0${b.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')}\n; Total bytes: ${tileArray.length}`;
      } else if (exportType === "Pascal") {
        return `Font_${record.ID}_${value.ID}: array[1..8] of byte = (${tileArray.map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')});\n{Total bytes: ${tileArray.length}}`;
      } else if (exportType === "MSX-BASIC") {
        return `Font_${record.ID}_${value.ID}:\n  DATA ${tileArray.map(b => b.toString(10)).join(', ')} : REM ${value.ID} ${value.Name}\nREM Total bytes: ${tileArray.length}`;
      } else if (exportType === "MSX-C") {
        return `unsigned char Font_${record.ID}_${value.ID}[] = { ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; /* ${value.ID} ${value.Name} */\n/* Total bytes: ${tileArray.length} */`;
      } else {
        return `const unsigned char Font_${record.ID}_${value.ID}[] = { ${tileArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; // ${value.ID} ${value.Name}\n// Total bytes: ${tileArray.length}`;
      }
    });
  
    const totalBytes = tiles.reduce((sum, tile) => {
      const matches = tile.match(/0x[0-9A-F]{2}/g);
      return sum + (matches ? matches.length : 0);
    }, 0);
    return getCommentedCode("Fonts set " + record.Description,exportType)+"\n" + tiles.join('\n')+"\n" + getCommentedCode("Total bytes: " +totalBytes.toString(),exportType)+"\n";
  }
}

function exportBitmapTilesMSXgl(record, width, height, halfWidth,exportType) {
  const totalTiles = record.Values.length;
  const tilesPerRow = Math.floor(256 / width);
  const rows = Math.ceil(totalTiles / tilesPerRow);
  const matrixHeight = rows * height;
  const matrixWidth = tilesPerRow * width;
  const matrix = Array.from({ length: matrixHeight }, () => Array(matrixWidth).fill(0));

  record.Values.forEach((value, index) => {
    const matrixX = (index % tilesPerRow) * width;
    const matrixY = Math.floor(index / tilesPerRow) * height;
    const tileMatrix = value.Matrices.find(m => m.ID === 1);
    tileMatrix.Values.forEach(cell => {
      matrix[matrixY + cell.PosY][matrixX + cell.PosX] = cell.Value;
    });
  });

  const flatArray = [];
  for (let y = 0; y < matrixHeight; y++) {
    for (let x = 0; x < matrixWidth; x += 2) {
      const byte = (matrix[y][x] << 4) | matrix[y][x + 1];
      flatArray.push(byte);
    }
  }

  const formattedArray = flatArray.map((b, i) => (i % 128 === 0 ? '\n' : '') + `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ');
  const totalBytes = flatArray.length;
  return getCommentedCode("Tiles set " + record.Description,exportType) + "\nconst unsigned char Tile_"+record.ID.toString()+"[] = " + formattedArray +";\n"+ getCommentedCode("Total bytes: " + totalBytes.toString(),exportType)+"\n";
}

function exportSprites(record, exportType) {
  if (record.Subtype === "Type 1") {
    return exportType1Sprites(record, exportType);
  } else if (record.Subtype === "Type 2") {
    return exportType2Sprites(record, exportType);
  }
}

function exportType1Sprites(record, exportType) {
  const [spriteWidth, spriteHeight] = record.Size.split('x').map(Number);
  const blocksPerRow = Math.ceil(spriteWidth / 8);
  const blocksPerColumn = Math.ceil(spriteHeight / 8);

  // Get unique colors from all matrices
  const uniqueColors = new Set();
  record.Values.forEach(value => {
    const matrix = value.Matrices.find(m => m.ID === 1);
    matrix.Values.forEach(cell => {
      uniqueColors.add(cell.Value);
    });
  });

  const colorArray = Array.from(uniqueColors).sort();
  let cArray =getCommentedCode("Sprites set " + record.Description,exportType) +"\n";
  let totalBytes = 0;

  record.Values.forEach((value, spriteIndex) => {
    const matrix = value.Matrices.find(m => m.ID === 1);
    if (exportType === "Assembly (binary)" || exportType === "Assembly (exadecimal)" || exportType === "Assembly (MACRO80)") {
      cArray += `Sprite_${record.ID}_${value.ID}:\n`;
    }
    else{
      cArray += getCommentedCode("Sprite_"+record.ID.toString()+"_"+value.ID.toString(),exportType)+"\n";
    }

    for (let blockY = 0; blockY < blocksPerColumn; blockY++) {
      for (let blockX = 0; blockX < blocksPerRow; blockX++) {
        colorArray.forEach(color => {
          const blockArray = [];

          for (let row = 0; row < 8; row++) {
            let byte = 0;
            for (let col = 0; col < 8; col++) {
              const cellX = blockX * 8 + col;
              const cellY = blockY * 8 + row;
              const cell = matrix.Values.find(cell => cell.PosX === cellX && cell.PosY === cellY);
              if (cell && cell.Value === color) {
                byte |= (1 << (7 - col));
              }
            }
            blockArray.push(byte);
          }

          if (exportType === "Assembly (binary)") {
            cArray += `  .db ${blockArray.map(b => `%${b.toString(2).padStart(8, '0')}`).join(', ')} ; Block (${blockY + 1}-${blockX + 1}) - Color: ${color}\n`;
          } else if (exportType === "Assembly (exadecimal)") {
            cArray += `  .db ${blockArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; Block (${blockY + 1}-${blockX + 1}) - Color: ${color}\n`;
          } else if (exportType === "Assembly (MACRO80)") {
            cArray += `  DEFB ${blockArray.map(b => `0${b.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')} ; Block (${blockY + 1}-${blockX + 1}) - Color: ${color}\n`;
          } else if (exportType === "Pascal") {
            cArray += `  Block_${blockY + 1}_${blockX + 1}: array[1..8] of byte = (${blockArray.map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}); {Color: ${color}}\n`;
          } else if (exportType === "MSX-BASIC") {
            cArray += `  Block_${blockY + 1}_${blockX + 1}:\n  DATA ${blockArray.map(b => b.toString(10)).join(', ')} : REM Color: ${color}\n`;
          } else if (exportType === "MSX-C") {
            cArray += `TINY Sprite_${record.ID}_${value.ID}[] = { ${blockArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; /* Block (${blockY + 1}-${blockX + 1}) - Color: ${color} */\n`;
          } else if (exportType === "C") {
            cArray += `unsigned char Sprite_${record.ID}_${value.ID}[] = { ${blockArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; // Block (${blockY + 1}-${blockX + 1}) - Color: ${color}\n`;
          }else {
            cArray += `\t${blockArray.map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}, // Block (${blockY + 1}-${blockX + 1}) - Color: ${color}\n`;
          }
          totalBytes += blockArray.length;
        });
      }
    }
  });

  cArray += getCommentedCode("Total bytes: " + totalBytes.toString(), exportType) + "\n";
  return cArray;
}

function exportType2Sprites(record, exportType) {
  const [spriteWidth, spriteHeight] = record.Size.split('x').map(Number);

  let cArray =getCommentedCode("Sprites set "+ record.Description,exportType)+"\n";
  let totalBytes = 0;

  record.Values.forEach(value => {
    const patternArray = Array(spriteHeight).fill(0).map(() => Array(spriteWidth).fill(0));
    const colorArray = Array(spriteHeight).fill(0).map(() => Array(spriteWidth).fill(0));

    value.Matrices.forEach(matrix => {
      matrix.Values.forEach(cell => {
        const x = cell.PosX;
        const y = cell.PosY;
        const colorIndex = parseInt(cell.Value, 16);

        patternArray[y][x] |= (1 << (7 - (x % 8)));
        colorArray[y][x] = colorIndex;
      });
    });

    if (exportType === "Assembly (binary)") {
      cArray += `Sprite_${record.ID}_${value.ID}_Pattern:\n  .db ${patternArray.flat().map(row => `%${row.toString(2).padStart(8, '0')}`).join(', ')}\n`;
      cArray += `Sprite_${record.ID}_${value.ID}_Color:\n  .db ${colorArray.flat().map(color => `%${color.toString(2).padStart(8, '0')}`).join(', ')}\n`;
    } else if (exportType === "Assembly (exadecimal)") {
      cArray += `Sprite_${record.ID}_${value.ID}_Pattern:\n  .db ${patternArray.flat().map(row => `0x${row.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n`;
      cArray += `Sprite_${record.ID}_${value.ID}_Color:\n  .db ${colorArray.flat().map(color => `0x${color.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}\n`;
    } else if (exportType === "Assembly (MACRO80)") {
      cArray += `Sprite_${record.ID}_${value.ID}_Pattern:\n  DEFB ${patternArray.flat().map(row => `0${row.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')}\n`;
      cArray += `Sprite_${record.ID}_${value.ID}_Color:\n  DEFB ${colorArray.flat().map(color => `0${color.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')}\n`;
    } else if (exportType === "Pascal") {
      cArray += `Sprite_${record.ID}_${value.ID}_Pattern: array[1..${spriteHeight}] of byte = (${patternArray.flat().map(row => `$${row.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')});\n`;
      cArray += `Sprite_${record.ID}_${value.ID}_Color: array[1..${spriteHeight}] of byte = (${colorArray.flat().map(color => `$${color.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')});\n`;
    } else if (exportType === "MSX-BASIC") {
      cArray += `Sprite_${record.ID}_${value.ID}_Pattern:\n  DATA ${patternArray.flat().map(row => row.toString(10)).join(', ')}\n`;
      cArray += `Sprite_${record.ID}_${value.ID}_Color:\n  DATA ${colorArray.flat().map(color => color.toString(10)).join(', ')}\n`;
    } else if (exportType === "MSX-C") {
      cArray += `TINY Sprite_${record.ID}_${value.ID}_Pattern[] = { ${patternArray.flat().map(row => `0x${row.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} };\n`;
      cArray += `TINY Sprite_${record.ID}_${value.ID}_Color[] = { ${colorArray.flat().map(color => `0x${color.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} };\n`;
    } else {
      cArray += `const unsigned char Sprite_${record.ID}_${value.ID}_Pattern[] = { ${patternArray.flat().map(row => `0x${row.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} };\n`;
      cArray += `const unsigned char Sprite_${record.ID}_${value.ID}_Color[] = { ${colorArray.flat().map(color => `0x${color.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} };\n`;
    }
    totalBytes += patternArray.flat().length + colorArray.flat().length;
  });

  cArray += `// Total bytes: ${totalBytes}\n`;
  return cArray;
}

function exportMaps(record, exportType) {
  let cArray =getCommentedCode("Maps set " + record.Description,exportType)+"\n";
  let totalBytes = 0;

  record.Values.forEach(value => {
    let mapArray = '';
    value.Map.forEach(cell => {
      mapArray += `0x${cell.TileId.toString(16).padStart(2, '0').toUpperCase()}, `;
    });
    mapArray = mapArray.slice(0, -2); // Remove the trailing comma and space

    if (exportType === "C" || exportType === "C (MSXgl)") {
      cArray += `const unsigned char Map_${record.ID}_${value.ID}[] = { ${mapArray} };\n`;
    } else if (exportType === "Assembly (binary)") {
      cArray += `Map_${record.ID}_${value.ID}:\n  .db ${mapArray.replace(/0x/g, '%')}\n`;
    } else if (exportType === "Assembly (exadecimal)") {
      cArray += `Map_${record.ID}_${value.ID}:\n  .db ${mapArray}\n`;
    } else if (exportType === "Assembly (MACRO80)") {
      cArray += `Map_${record.ID}_${value.ID}:\n  DEFB ${mapArray.replace(/0x/g, '0').replace(/, /g, 'H, ')}H\n`;
    } else if (exportType === "Pascal") {
      cArray += `Map_${record.ID}_${value.ID}: array[1..${value.Map.length}] of byte = (${mapArray.replace(/0x/g, '$')});\n`;
    } else if (exportType === "MSX-BASIC") {
      cArray += `Map_${record.ID}_${value.ID}:\n  DATA ${mapArray.replace(/0x/g, '').replace(/, /g, ', ')}\n`;
    } else if (exportType === "MSX-C") {
      cArray += `TINY Map_${record.ID}_${value.ID}[] = { ${mapArray} };\n`;
    } else {
      cArray += `const unsigned char Map_${record.ID}_${value.ID}[] = { ${mapArray} };\n`;
    }
    totalBytes += value.Map.length;
  });

  cArray += `// Total bytes: ${totalBytes}\n`;
  return cArray;
}

function exportImages(record, exportType) {
  let cArray =getCommentedCode("Images set " + record.Description,exportType)+"\n";
  if (exportType === "Assembly (binary)" || exportType === "Assembly (exadecimal)" || exportType === "Assembly (MACRO80)"){
    cArray += `; Images set "${record.Description}"\n`;
  }

  let totalBytes = 0;

  record.Values.forEach(value => {
    const matrix = value.Matrices.find(m => m.ID === 1);
    const [width, height] = record.Size.split('x').map(Number);
    const halfWidth = width / 2;
    const imageArray = Array.from({ length: height }, () => Array(halfWidth).fill(0));

    matrix.Values.forEach(cell => {
      const byteIndex = Math.floor(cell.PosX / 2);
      const nibble = cell.PosX % 2 === 0 ? (cell.Value << 4) : cell.Value;
      imageArray[cell.PosY][byteIndex] |= nibble;
    });

    if (exportType === "Assembly (binary)") {
      cArray += `Image_${record.ID}_${value.ID}:\n  .db ${imageArray.flat().map(b => `%${b.toString(2).padStart(8, '0')}`).join(', ')} ; ${value.Name}\n`;
    } else if (exportType === "Assembly (exadecimal)") {
      cArray += `Image_${record.ID}_${value.ID}:\n  .db ${imageArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} ; ${value.Name}\n`;
    } else if (exportType === "Assembly (MACRO80)") {
      cArray += `Image_${record.ID}_${value.ID}:\n  DEFB ${imageArray.flat().map(b => `0${b.toString(16).padStart(2, '0').toUpperCase()}H`).join(', ')} ; ${value.Name}\n`;
    } else if (exportType === "Pascal") {
      cArray += `Image_${record.ID}_${value.ID}: array[1..${height}] of byte = (${imageArray.flat().map(b => `$${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')}); { ${value.Name}}\n`;
    } else if (exportType === "MSX-BASIC") {
      cArray += `Image_${record.ID}_${value.ID}:\n  DATA ${imageArray.flat().map(b => b.toString(10)).join(', ')} : REM ${value.Name}\n`;
    } else if (exportType === "MSX-C") {
      cArray += `TINY Image_${record.ID}_${value.ID}[] = { ${imageArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; /* ${value.Name} */\n`;
    } else {
      cArray += `const unsigned char Image_${record.ID}_${value.ID}[] = { ${imageArray.flat().map(b => `0x${b.toString(16).padStart(2, '0').toUpperCase()}`).join(', ')} }; // ${value.Name}\n`;
    }
    totalBytes += imageArray.flat().length;
  });

  cArray += `// Total bytes: ${totalBytes}\n`;
  return cArray;
}

function getCommentedCode(text,exportType){
  switch (exportType) {
    case "Assembly (binary)":
    case "Assembly (exadecimal)":
    case "Assembly (MACRO80)":
      return "; "+text;
    break
    case "Pascal":
      return "{"+text +"}";
    break;
    case "MSX-BASIC":
      return "' "+text;
    break;
    case "MSX-C":
      return "/* "+text+" */";
    break;
    case "C (MSXgl)":
    case "C":
      return "// "+text;
    break;
  }
}

